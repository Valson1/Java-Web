Вопрос 1.<br />
Что появится в консоли в результате работы фрагмента программы?<br />
String a = "java";<br />
a.toUpperCase();<br />
System.out.println(a);<br />
**Ответ.** Вывод: java. Изменение строки всегда приводит к созданию нового объекта в heap.Класс String - иммутабельный.
**Источник.** <br />Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск :Четыре четверти, 2020 стр.226
Четыре четверти, 2020 стр.226

Вопрос 2.<br />
Что появится в консоли в результате работы фрагмента программы?<br />
String s1 = "Java";<br />
String s2 = "Java";<br />
String s3 = new String("Java");<br />
System.out.println("s1 == s2 : " + (s1 == s2));<br />
System.out.println("s1 == s3 : " + (s1 == s3));<br />
System.out.println(s1.equals(s3));<br />
Поясните ответ.<br />
**Ответ.** <br />
Вывод: В данной ситуации s2 ассоциируется с уже существующим литералом, так как объект s1 уже сделал ссылку на этот литерал. При<br />
создании s3 происходит вызов конструктора, т.е. выделение памяти происходит<br />
раньше инициализации, и в этом случае в куче создается новый объект.<br />
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск :Четыре четверти, 2020 стр.228 <br />

Вопрос 3.<br />
Можно ли выполнить наследование от класса String? <br />
Почему?<br />
**Ответ.** Класс String обьявлен с модификатором final. <br />
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск :Четыре четверти, 2020 стр.228<br />

Вопрос 4.
Назовите основные, на ваш взгляд, методы класса String.
**Ответ.** String concat(String s) или оператор «+» — слияние строк; <br />
String substring(int n, int m) — извлечение из строки подстроки длины <br />
m-n, начиная с позиции n. Нумерация символов в строке начинается с нуля; <br />
int length() — определение длины строки; <br />
static String format(String format, Object… args), format(Locale l, String<br />
format, Object… args)  — создание форматированной строки, полученной<br />
с использованием формата, локализации и др.;<br />
String[] split(String regex), String[] split(String regex, int limit) — поиск<br />
вхождения в строку заданного регулярного выражения-шаблона в качестве разделителя и деление исходной строки в соответствии с этим разделителем на<br />
массив строк;<br />
boolean isEmpty() — возвращает true, если длина строки равна 0;<br />
boolean isBlank() — возвращает true, если строка пуста или содержит только пробельные символы;<br />
static String valueOf(type v) — преобразование переменной базового типа<br />
к строке;<br />
String toUpperCase()/toLowerCase() — преобразование всех символов вызывающей строки в верхний/нижний регистр;<br />
String replace(char с1, char с2) — замена в строке всех вхождений первого<br />
символа вторым символом;<br />
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск :Четыре четверти, 2020 стр.227<br />

Вопрос 5.<br />
Какие разновидности конструкторов использует класс String?<br />
**Ответ.** <br />
Класс String поддерживает несколько конструкторов, например: String(),<br />
String(String original), String(byte[] bytes), String(char[] value), String(char[]<br />
value, int offset, int count), String(StringBuffer buffer), String(StringBuilder<br />
builder)<br />
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск :Четыре четверти, 2020 стр.227<br />

Вопрос 6.<br />
Какие классы в стандартной библиотеке Java работают со строками?<br />
**Ответ.** Patcher,Matcher,StringBuilder,StringBuffer,Formatter,NumberFormat,Locale,DateFormat.<br />
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск :Четыре четверти, 2020 гл. Строки<br />

Вопрос 7.<br />
Почему экземпляры класса String в Java неизменные и финализированные?<br />
**Ответ.** <br />
Безопасность и String pool основные причины неизменяемости String в Java.<br />

Безопасность объекта неизменяемого класса String обусловлена такими фактами:<br />

1)вы можете передавать строку между потоками и не беспокоиться что она будет изменена<br />
2)нет проблем с синхронизацией (не нужно синхронизировать операции со String)<br />
3)отсутствие утечек памяти<br />
4)в Java строки используются для передачи параметров для авторизации, открытия файлов и т.д. - неизменяемость позволяет избежать проблем с доступом<br />
5)возможность кэшировать hash code<br />
String pool позволяет экономить память и не создавать новые объекты для каждой повторяющийся строки. В случае с изменяемыми строками - изменение одной приводило бы к изменению всех строк одинакового содержания.<br />
**Источник.** <br /> https://ru.stackoverflow.com/questions/544413/%D0%9F%D0%BE%D1%87%D0%B5%D0%BC%D1%83-string-%D0%BD%D0%B5%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D1%8F%D0%B5%D0%BC%D1%8B%D0%B9-%D0%B8-%D0%BA%D0%B0%D0%BA-%D1%8D%D1%82%D0%BE-%D0%BF%D0%BE%D0%BC%D0%BE%D0%B3%D0%B0%D0%B5%D1%82-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D1%83<br />
Вопрос 8.<br />
Заполните ячейки таблицы (Да/Нет).<br />
Characteristic 				String		StringBuilder		StringBuffer<br />
Неизменяемый (Immutable)?<br />		
Имеет пул (Pooled)?<br />
Потокобезопасный (Thread-safe)?<br />
Может изменять размер?<br />
**Ответ.** Неизменяемый: да, нет, нет. <br />
Имеет пул: да, нет, нет.<br />
Потокобезопасный:да, нет, да.<br />
Может изменять размер: нет(да если переинициализировать в другую переменную),да,да<br />
**Источник.** <br />

Вопрос 9.<br />
В чем разница и что общего между StringBuffer и StringBuilder?<br />
**Ответ.** StringBuffer потокобезопасный и методы синхронизированны.Поэтому StringBuilder работает быстрее.<br />
**Источник.** <br /><br />

Вопрос 10.<br />
Когда лучше использовать StringBuffer, а когда StringBuilder?<br />
**Ответ.** Работать с классами нужно, когда  необходимо изменить содержимое.StringBuffer используется для работы с потоками. StringBuilder для улучшения производительности<br />
**Источник.** <br />

Вопрос 11.<br />
Какие методы имеются в классах StringBuffer и StringBuilder, которые отсутствуют в классе String?<br />
**Ответ.** void setLength(int newLength) — установка размера буфера;<br />
void ensureCapacity(int minimumCapacity) — установка гарантированного минимального размера буфера;<br />
void trimToSize() — сжатие буфера до размеров контента;<br />
int capacity() — возвращение текущего размера буфера;<br />
StringBuffer append(parameters)  — добавление к содержимому объекта<br />
строкового представления аргумента, который может быть символом, значением<br />
базового типа, массивом и строкой;<br />
StringBuffer insert(parameters)  — вставка символа, объекта или строки<br />
в указанную позицию;<br />
StringBuffer deleteCharAt(int index)  — удаление символа; StringBuffer<br />
delete(int start, int end) — удаление подстроки; StringBuffer reverse() — обращение содержимого объекта.<br />
**Источник.** <br /><br />

Вопрос 12. <br />
Какие методы сравнения строк имеются в строковых классах?<br />
**Ответ.** String - переопределенный equals и equalsIgnoreCase,int compareTo(String s) и compareToIgnoreCase(String s). StringBuilder,StringBuffer - метод класса String contentEquals() 
**Источник.** <br />

Вопрос 13.  <br />
Используя функции строковых классов, написать фрагмент программы, которая будет определять, является ли строка палиндромом. <br />
**Ответ.**  <br />
boolean isPalindrom = false; <br />
	String b = "javaj"; <br />
	StringBuilder a = new StringBuilder(b); <br />
	if(a.reverse().toString().equals(b)) { <br />
	    isPalindrom = true; <br />
	} <br />
	System.out.println("Condition is " + isPalindrom); <br />
**Источник.** <br />

Вопрос 14. <br />
Что появится в консоли в результате работы фрагмента программы? <br />
final String ZA = " за "; <br />
String value = "ОТЧЕТ о перевозках пассажиров за январь 2019 г."; <br />
String[] monthYear = value.split(ZA)[1].split(" ",3); <br />
System.out.println(Arrays.toString(monthYear)); <br />
Поясните ответ. <br />
**Ответ.**  <br />
Вывод:[январь, 2019, г.] <br />
Действие value.split(ZA) делит строку value на массив строк [ОТЧЕТ о перевозках пассажиров,январь 2019 г.].Так как далее следует первый индекс массива, строка "январь 2019 г." разбивается на массив строкс помощью метода split(" ",3). <br />
**Источник.** <br />

Вопрос 15. <br />
Что появится в консоли в результате работы фрагмента программы? <br />
String s4 = "1" + 2 + 3; <br />
String s5 = 1 + 2 + "3"; <br />
System.out.println(s4); <br />
System.out.println(s5); <br />
Поясните ответ. <br />
**Ответ.**  <br />
123 <br />
33 <br />
Так как ассоциативность оператора сложения слева направо, в строке 1 первым действием выполняется "1" + 2, где 2 преобразуется в строку. В результате, получается строка 12, которая конкатенируется с 3 и получается 123. <br />
Строка 2 начинается со сложения двух интов 1 + 2. Результат получается 3. Далее целое число 3 преобразуется в строку и конкатенируется со строкой "33". <br />
**Источник.** <br />

Вопрос 16. <br />
Что появится в консоли в результате работы фрагмента программы? <br />
String s = "abcde "; <br />
System.out.println(s.trim().length()); <br />
System.out.println(s.charAt(4)); <br />
System.out.println(s.indexOf('e')); <br />
System.out.println(s.indexOf("de")); <br />
System.out.println(s.substring(2, 4).toUpperCase()); <br />
System.out.println(s.replace('a', '1')); <br />
System.out.println(s.contains("DE")); <br />
System.out.println(s.startsWith("a")); <br />
Поясните ответ. <br />
**Ответ.**  <br />
5 - Метод s.trim() убирает первые и последние пробелы в строке  <br />
e - Метод s.charAt(4) возвращает символ по указанному индексу <br />
4 - Метод s.indexOf('e') возвращает индекс первого соответствия с указанным символом <br />
3 - Метод s.indexOf('de') возвращает индекс первого соответствия с указанным символом <br />
CD - Метод s.substring(2,4) выделяет под строку по заданным индексам(endIndex - 1), метод toUpperCase() устанавливает строку в верхний регистр. <br />
1bcde - Метод s.replace ('a','1') заменяет все символы a, на символы 1 во всей строке.  <br />
false - Метод s.contains("DE") проверяет строку на наличие соответствующих символов с учетом регистра. <br />
true - Метод s.startsWith("a") проверяет начинается ли строка с указанной строки. <br />
Cтроки неизменяемы. Для изменения строк необходимо переинициализация к другой переменной. <br />
**Источник.** <br />

Вопрос 17. <br />
Что появится в консоли в результате работы фрагмента программы? <br />
StringBuilder b = new StringBuilder(); <br />
b.append(12345).append('-'); <br />
System.out.println(b.length()); <br />
System.out.println(b.indexOf("-")); <br />
System.out.println(b.charAt(2)); <br />
StringBuilder b2 = b.reverse(); <br />
System.out.println(b.toString()); <br />
System.out.println(b == b2); <br />
Поясните ответ. <br />
**Ответ.**  <br />
В отличие от  класса String  StringBuilder меняет свое состояние. <br />
6 - Метод b.length() возвращает длину строки длина строки <br />
5 - Метод b.indexOf("-") возвращает индекс заданного элемента  <br />
3 - Метод b.charAt(2) возвращает символ заданного индекса <br />
-54321 - Метод b2.reverse() возвращает строку наоборот <br />
true - Операция == сравнивает ссылки на обьекты.Так как обьект изменяемый результат будет true. <br />
**Источник.** <br />

Вопрос 18. <br />
Что появится в консоли в результате работы фрагмента программы? <br />
StringBuilder s = new StringBuilder("abcde"); <br />
s.insert(1, '-').delete(3, 4); <br />
System.out.println(s); <br />
System.out.println(s.substring(2, 4)); <br />
Поясните ответ. <br />
**Ответ.**  <br />
a-bde - Метод insert(1,'-') вставляет указанный символ на указанный индекс.Другие символы сдвигаются в право(в том числе и символ стоявший на указанном индексе). Далее метод delete(2,4) удаляет символы в строке по от индекса 2 до индекса 4 - 1. <br />
bd - Метод substring возвращает подстроку в соответствии с указанными индексами(endIndex - 1).  <br />
**Источник.** <br />

Вопрос 19. <br />
StringBuffer sb = new StringBuffer("abcde"); <br />
sb.insert(2,"123"); <br /> <br />
sb.append("456"); <br />
sb.reverse(); <br />
Поясните ответ. <br />
**Ответ.** Если вывести строку в консоль результат будет: 654edc321ba <br />
Метод sb.insert(2,"123") вставляет указанную строку на указанный индекс. ab123cde <br />
Метод sb.append("456")добавляет указанную строку к существующей. ab123cde452  <br />
sb.reverse() разворачивает строку. <br />
**Источник.** <br /> 

Вопрос 20.<br />
Каким образом можно сцепить строки Java? <br />
Назовите не менее 3 способов.<br />
**Ответ.** <br />
Конкатенация строк оператором + или методом concat() класса String.<br />
Присоединение строк методом join() класса String.<br />
Присоединение строк методом append класса StringBuilder<br />
**Источник.** <br /> 

Вопрос 21. <br />
Чем отличаются пустая и нулевая строки?<br />
**Ответ.** Пустая строка не имеет символ и ее длина равна нулю.<br />
**Источник.** <br />

Вопрос 22.  <br />
В какой кодировке хранятся символы в строке? <br />
**Ответ.** Unicode <br />
**Источник.** <br />

Вопрос 23.  <br />
Какие интерфейсы реализуют классы String, StringBuffer и StringBuilder? <br />
**Ответ.** Serializable, Comparable<String>, CharSequence <br />
**Источник.** <br />

Вопрос 24.  <br />
Что такое кодовые точки и кодовые единицы? <br />
**Ответ.** Единица кода - это 16-битный двоичный код, а кодовая точка - это один или два 16-битных двоичного кода. То есть одна кодовая точка может быть выражена как одна кодовая единица или две кодовые единицы. <br />
**Источник.** <br />

Вопрос 25. <br />
Объясните назначение метода intern().<br />
Что появится в консоли в результате работы фрагмента программы?<br />
class GFG {<br />
	public static void main(String[] args) {<br />
		String s1 = new String("GFG");<br />
		String s2 = s1.intern();<br />
		System.out.println(s1 == s2);<br />
		System.out.println(s1.equals(s2));<br />
		String s3 = "GFG";<br />
		System.out.println(s2 == s3);<br />
	}
}
Поясните ответ.<br />
**Ответ.** <br />
false - s1 и s2 ссылки не равны, так как метод s1.intern() помещает строку s1 в пул строк.<br />
true - s1 и s2 сравниваются по значению<br />
true - s2 и s3 сравниваются ссылки (s2 находится в пуле строк)<br />
**Источник.** <br /> 

Вопрос 26.<br />
Как преобразовать строку в число?<br />
**Ответ.** С помощью конкатенации. Также через методы подклассов Number parseXXX, где XXX - имя класса обертки.<br />
**Источник.** <br /> 

Вопрос 27.<br />
Какой метод вызывается для преобразования переменной в строку?<br />
**Ответ.** Метод valueOf() или метод toString() не для примитивов.<br />
**Источник.** <br /> 

Вопрос 28.<br />
Каким методом в классе String можно проверить строку на соответствие регулярному выражению?<br />
**Ответ.** matches(String regex);<br />
**Источник.** <br /> 

Вопрос 29.<br />
Создайте класс с полями: int, long, float и double, String. <br />
Сделайте для этого класса метод toString(), использующий String.format(), и выведите содержимое полей на экран в произвольном порядке, используя спецификаторы.<br />
**Ответ.** <br />
public class Runner {<br />
    long l = 10;<br />
    float f = 2.3f;<br />
    int i = 123;<br />
    double d = 1.4;<br />
    String s = "ewrw";<br />
    @Override<br />
    public String toString() {<br />
	return String.format("Long = %d, float = %.1f, int = %d, double = %.1f, String = %s",l,f,i,d,s);<br />
    }<br />
    public static void main(String[] args) {<br />
	System.out.println(new Runner());<br />
    }<br />
**Источник.** <br /> 

Вопрос 30.<br />
Опишите: <br />
назначение класса Formatter, <br />
методы format(), <br />
спецификаторы формата.<br />
**Ответ.** Класс Formatter используется для создания форматированного текстового вывода и преобразует двоичную форму представления данных<br />
в форматированный текст.<br />
Formatter format(Locale loc, String fmtString, Object…args) — форматирует аргументы, переданные в аргументе переменной длины args, в соответствии со спецификаторами формата, содержащимися в fmtString.<br />
При форматировании используются региональные установки, заданные в lос. Возвращает вызывающий объект.<br />
%a Шестнадцатеричное значение с плавающей точкой<br />
%b Логическое (булево) значение аргумента<br />
%c Символьное представление аргумента<br />
%d Десятичное целое значение аргумента<br />
%h Хэш-код аргумента<br />
%f Десятичное значение с плавающей точкой<br />
%o Восьмеричное целое значение аргумента<br />
%n Вставка символа новой строки<br />
%s Строковое представление аргумента<br />
%t Время и дата<br />
%x Шестнадцатеричное целое значение аргумента<br />
**Источник.** <br />Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск :Четыре четверти, 2020 гл.<br />

Вопрос 31.
Что представляет собой регулярное выражение? <br />
На каких классах базируются regex-возможности языка Java? <br />
В каком пакете эти классы расположены?<br />
**Ответ.** Регулярные выражения или шаблоны используются для поиска подстроки<br />
или строки, соответствующей шаблону в строке, тексте или другом объекте,<br />
представляющем последовательность символов.Регулярные выражения базируются на классах Pattern и Matcher расположенных в пакете java.util.regex<br />
**Источник.** <br /> 

Вопрос 32.<br />
Опишите назначение классов Pattern и Matcher. <br />
Каким образом они связываются? <br />
Предоставить простейший код их взаимодействия.<br />
**Ответ.** Класс Pattern используется для простой обработки строк и объекта хранителя регулярного выражения. Объект класса Pattern, в свою очередь, используется для более сложной обработки символьной информации классом<br />
Matcher.Методы класса Pattern позволяют проверять на соответствие шаблону целую строку и разбивать строку на части, используя шаблон как разделитель.<br />
Для определения подстрок, соответствующих шаблону, необходимо использовать класс Matcher.<br />
Pattern pattern = Pattern.compile("\\d+");<br />
Matcher matcher = pattern.matcher("123ewr");<br />
matcher.find();<br />
System.out.println(matcher.group());<br />
<br />
123<br />
**Источник.** <br /> 

Вопрос 33.<br />
При помощи регулярных выражений найти все ссылки внутри веб-страницы, то есть адреса, указанные в атрибуте href.<br />
**Ответ.** <br />
**Источник.** <br /> 
Вопрос 34.<br />
Какой из способов сравнения строк предпочтительнее?<br />
str.equals("abc");<br />
или<br />
"abc".equals(str);<br />
Поясните ответ.<br />
**Ответ.** Первый способ кидает NullPointerException, если str = null. Результат второго способа будет false, если str = null.<br />
**Источник.** <br /> 

Вопрос 35.
Как сравнить объекты StringBuilder и StringBuffer?<br />
**Ответ.** Так как equals не переопределен в этих классах, обьекты StringBuilder и StringBuffer сравниваются через метод класса String contentEquals.<br />
**Источник.** <br />

Вопрос 36.<br />
Что появится в консоли в результате работы фрагмента программы?<br />
System.out.printf(<br />
	"%d студентов пришли сдавать зачет по %8.10s, \n" <br />
	+ "из них не сдали %d, %s", <br />
	10, "J2SE", 5, "а остальные сдали на отлично"<br />
);<br />
Поясните ответ.<br />
**Ответ.** <br />
**Источник.** <br /> 

Вопрос 37.<br />
Сформировать регулярное выражение, при помощи которого можно выбрать все страницы, начинающиеся с "http" или "https" и заканчивающиеся на "by".<br />
**Ответ.** Pattern pattern = Pattern.compile("^(https?)://\\w+(.by)$");<br />
**Источник.** <br />

Вопрос 38.<br />
Сформировать регулярное выражение, при помощи которого можно выбрать все  с ресурса https://bsut.by.<br />
Например, запрос https://bsut.by?value1=5&value2=10&iscan=true.<br />
Вывод<br />
value1=5<br />
value2=10<br />
iscan=true<br />
**Ответ.** Pattern pattern = Pattern.compile("(^?\\w+=\\w+&?)+");<br />
**Источник.** <br />

Вопрос 39.<br />
Базовые конструкции регулярных выражений, синтаксис (очень коротко, суть). Специальные символы, основные логические конструкции, предопределенные классы символов, логические операции, квантификаторы, группы.<br />
**Ответ.** <br />
Логические конструкции<br />
ab после а следует b<br />
a|b a или b<br />
Конструкции<br />
[abc] a или b или c<br />
[^abc] символ, исключая a, b и c<br />
[a-z] символ между a и z<br />
Предопределенные классы символов<br />
. любой символ<br />
\d или \p{Digit} [0-9]<br />
\D [^0-9]<br />
\s или \p{Space} [ \t\n\x0B\f\r]<br />
\S [^\s]<br />
\w [0-9_A-Za-z]<br />
\W [^\w]<br />
\p{Lower} [a-z]<br />
\p{Upper} [A-Z]<br />
\p{Alpha} [a-zA-Z]<br />
\p{Alnum} [\p{Alpha}\p{Digit}]<br />
\p{Punct} !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~<br />
\p{Blank} пробел или табуляция<br />
^ или \A начало строки<br />
$ или \Z конец строки<br />
Квантификаторы<br />
a? a один раз или ни разу<br />
a* a ноль или более раз<br />
a+ a один или более раз<br />
a{n} a n раз<br />
a{n,} a n или более раз<br />
a{n,m} a от n до m<br />
**Источник.** <br /> 

Вопрос 40.<br />
Назовите основные, на ваш взгляд, методы класса Pattern.<br />
**Ответ.** <br />
static Pattern compile(String regex) — возвращает Pattern, который соответствует regex;<br />
String[] split(CharSequence input)  — разбивает на массив строку input,<br />
учитывая, что разделителем является шаблон;<br />
Matcher matcher(CharSequence input) — возвращает Matcher, с помощью<br />
которого можно находить соответствия в строке input.<br />
**Источник.** <br /> <br />
<br />
Вопрос 41.<br />
Назовите основные, на ваш взгляд, методы класса Matcher.<br />
**Ответ.** <br />
boolean lookingAt() — поиск последовательности символов, начинающейся<br />
с начала строки и соответствующей шаблону;<br />
boolean find() или boolean find(int start) — определение последовательности символов, соответствующих шаблону, в любом месте строки. Параметр<br />
start указывает на начальную позицию поиска.<br />
String group() — возвращает всю подпоследовательность, удовлетворяющую шаблону или нулевой группе;<br />
int start() — возвращает индекс первого символа подпоследовательности,<br />
удовлетворяющей шаблону;<br />
int start(int group) — возвращает индекс первого символа указанной группы;<br />
int end() — возвращает индекс последнего символа подпоследовательности, удовлетворяющей шаблону;<br />
int end(int group) — возвращает индекс последнего символа указанной группы;<br />
**Источник.** <br /> <br />

Вопрос 42.
Что появится в консоли в результате работы фрагмента программы?<br />
System.out.println{"-1234".matches("-?\\d+"));<br />
System. out. println ("5678". matches (" - ? \ \d+"));<br />
System.out.println("+9ll".matches("-?\\d+"));<br />
System.out.println("+911".matches("(-|\\+)?\\d+"));<br />
Поясните ответ.<br />
**Ответ.** <br />
true - "-1234" "минус" один раз или ни разу. \\d+ число один раз или более раз<br />
true - "5678"  "минус" один раз или ни разу. \\d+ число один раз или более раз<br />
false "+9ll" здесь плюс значит false<br />
true "+911" "минус" или "плюс" один раз или ни разу. \\d+ число один раз или более раз<br />
**Источник.** <br /> <br />

Вопрос 43.<br />
Что появится в консоли в результате работы фрагмента программы?<br />
System.out.println(<br />
	Arrays<br />
	.toString("Then, when you have found the gold."<br />
		.split("n\\W+")<br />
	)<br />
);<br />
Поясните ответ.<br />
**Ответ.** <br />
[The, whe, you have found the gold.]. split("n\\W+") возвращает массив строк в соответствии с рег.выр. Then и when имеют букву n,после Then идет запятая, но она исключается регулярным выражением \\W+, что означает исключая [0-9_A-Za-z] один или более раз<br />
**Источник.** <br /> <br />

Вопрос 44.<br />
Сформируйте и протестируйте регулярное выражение, которое проверяет, что предложение начинается с прописной буквы и завершается точкой.<br />
**Ответ.** <br />
Pattern pattern = Pattern.compile("^(\\p{Upper}).*(\\.)$");<br />
	Matcher matcher = pattern.matcher("Adwe234_.");<br />
	matcher.find();<br />
	System.out.println(matcher.group());<br />
**Источник.** <br /> <br /> 

Вопрос 45.<br />
Сформируйте и протестируйте регулярное выражение, которое заменяет все гласные подчеркиваниями в предложении <br />
"Then, when you have found the gold".<br />
**Ответ.** <br />
String str = "Then, when you have found the gold";<br />
	System.out.println(str.replaceAll("[aeyuio]|[AEYUIO]", "_"));<br />
**Источник.** <br /> <br />

Вопрос 46.<br />
Определите, будет ли найдено в строке <br />
"Java now has regular expressions" <br />
совпадение для следующих выражений:<br />
^Java <br />
\Breg.*<br />
n.w\s+h(a|i)s<br />
s?<br />
s*<br />
s+<br />
S{4}<br />
S{1}<br />
S{0,3}<br />
Поясните ответ.<br />
**Ответ.** <br />
^Java - найдено Java, ^ начало строки.<br />
\Breg.* - не найдено<br />
n.w\s+h(a|i)s - найдено now has. <br />
s? - найдено совпадение пустая строка, так как s может быть один раз или ни разу.<br />
s* - найдено совпадение пустая строка, так как s может быть ни разу или более раз.<br />
s+ -  найдено совпадение s, так как s может быть один раз или более раз.<br />
S{4} - не найдено. S нет в строке<br />
S{1} - не найдено. S нет в строке<br />
S{0,3} найдено пустая строка. S должно быть в строке от 0 до 3.<br />
**Источник.** <br /> <br />

Вопрос 47.<br />
Примените регулярное выражение<br />
(?i)((^[aeiou])|(\s+[aeiou]))\w+?[aeiou]\b<br />
к строке<br />
"Arline ate eight apples and one orange while Anita hadn't any"<br />
Поясните ответ. <br />
**Ответ.** <br />
**Источник.** <br /> <br />

Вопрос 48.<br />
Какие подстроки извлекают следующие регулярные выражения?<br />
[0-6]<br />
[^n-p]<br />
[A-Za-z0-9_]<br />
\w<br />
[A-C][n-p][a-c]<br />
waz{3,5}up<br />
[abc]+<br />
.*<br />
**Ответ.** <br />
[0-6] - цифра от 0 до 6<br />
[^n-p] - буква, исключая буквы от n до p<br />
[A-Za-z0-9_] - буква алфавита или цифра или нижнее подчеркивание<br />
\w - буква алфавита или цифра или нижнее подчеркивание<br />
[A-C][n-p][a-c] Набор символов: 1)от A до C. 2)от n до p 3)от a до c.<br />
waz{3,5}up - wazzzup,wazzzzup,wazzzzzup<br />
[abc]+ - (a или b или с) один или более раз<br />
.* - любой символ более одного раза или пустая строка.<br />
**Источник.** <br /> <br />

Вопрос 49.
Сформируйте регулярное выражение, которое находит предложения, начинающиеся с "Input:" и заканчивающиеся на "successful".<br />
**Ответ.** <br />
Pattern pattern = Pattern.compile("^(Input:).*(successful)$");<br />
**Источник.** <br /> <br />

Вопрос 50
Сформируйте регулярное выражение, которое выделяет в обрабатываемом тексте названия файлов (имя + расширение) графических форматов gif, png, jpg.<br />
**Ответ.** Pattern pattern = Pattern.compile(".+\\.(gif|png|jpg)$");<br />
**Источник.** <br /> <br />