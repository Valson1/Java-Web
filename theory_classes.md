Какие уровни доступа есть у класса на верхнем уровне, т.е. у внешнего класса?<br />
**Ответ.**  public,package private.<br />
**Источник.**https://docs.oracle.com/javase/tutorial/java/javaOO/classdecl.html<br />

Что является членами класса?<br />
**Ответ.**  поля, методы, внутренние классы , конструкторы, логические блоки.<br />
**Источник.**https://docs.oracle.com/javase/tutorial/java/javaOO/classdecl.html

Что еще можно определить в классе кроме членов?<br />
**Ответ.**  конструкторы, внутренние классы, логически и статические блоки.<br />
**Источник.**https://docs.oracle.com/javase/tutorial/java/javaOO/classdecl.html

Какие уровни доступа есть у членов класса?<br />
 **Ответ.** public, private, protected, deefault(package private).<br />
**Источник.**https://docs.oracle.com/javase/tutorial/java/javaOO/classdecl.html

Какие модификаторы необходимы для определения константы:<br />
1. класса,<br />
2. экземпляра класса?<br />
**Ответ.** 1. final static;2. final. <br />
**Источник.**https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html

Обратный вопрос. Допустим, у некоторого класса есть 4 следующих поля:<br />
class SomeClass {<br />
	private int a;<br />
	private final int b;<br />
private static int c; <br />
private static final int D;<br />
...<br />
}<br />
Как можно назвать данные поля в зависимости от комбинации модификаторов static и final?<br />
**Ответ.** private int a - переменная экземпляра класса;private final int b - константа экземпляра класса;private static int c - переменная класса;private static final int D - константа класса;<br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.

Может ли класс не иметь ни одного конструктора? Почему?<br />
**Ответ.** Нет ,не может. Если в классе не обьявлен конструктор явно, он будет обьявлен не явно. Такой конструктор называется конструктором по умолчанию.<br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.
 
Перечислите отличия конструктора от метода.<br />
**Ответ.** 1) Имя конструктора должно быть как у класса в котором он объявлен.Имя метода может быть произвольным.<br />
2)Конструктор не имеет возвращаемого значения;метод обязан иметь возвращаемое значение.<br />
3) В отличие от метода, конструктор не может иметь следующие свойства, не связанные с доступом:abstract, final, native, static,synchronized.<br />
4)Конструкторы не могут быть унаследованы, методы наследуются.<br />
5)Конструктор должен создать экземпляр класса. Метод - это действие объекта.<br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.

Как и в каком месте можно вызвать из одного конструктора другой конструктор этого же класса?<br />
**Ответ.** Это возможно с помощью ключевого слова this.В общем виде это выглядит так.<br />
public Constructor(...){<br />
this(...)<br />
...<br />
}<br />
Необходимо, чтобы конструкция this(...) была первым оператором в теле этого конструктора.<br />
**Источник.**

Как и в каком месте можно вызвать конструктор суперкласса?<br />
**Ответ.** Это возможно с помощью ключевого слова super.В общем виде это выглядит так.<br />
public Constructor(...){<br />
super(...)<br />
...<br />
}<br />
Необходимо, чтобы конструкция super() была первым оператором в теле этого конструктора.<br />
**Источник.**

Что делает компилятор, если в конструкторе нет вызова другого конструктора или конструктора суперкласса?<br />
**Ответ.** Каждый конструктор при отсутствии явных вызовов других конструкторов неявно вызывает с помощью super().<br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.

Можно ли одновременно использовать конструкции this() и super() в одном и том же конструкторе?<br />
Обоснуйте ответ.<br />
**Ответ.** Нельзя,так как необходимое условие для обоих случаев - быть первым оператором в теле конструктора.<br />
**Источник.**

Может ли быть приватный уровень доступа у конструктора? Если да, то для каких целей он необходим?<br />
**Ответ.** Да.Реализация статического метода фабрики внутри самого класса. Для реализации паттерна Синглтон. Для утилитного класса.<br />
**Источник.**

Какие модификаторы может иметь конструктор?<br />
**Ответ.**  private, protected, package private,public<br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.

Конструктор принадлежит классу или экземпляру класса?<br />
**Ответ.**  экземпляру класса.<br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.

Можно ли наследовать конструктор?<br />
Если да, то приведите примеры. <br />
**Ответ.**  Конструкторы не передаются производному классу при наследовании.Можно вызвать конструктор суперкласса с использованием ключевого слова super().<br />
**Источник.**

Какой тип возвращаемого конструктором значения?<br />
**Ответ.**  у конструктора нет возвращаемого значения.<br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.

Дан класс.<br />
class Null {<br />
	//фрагмент 1<br />
	// метод с именем класса Null, возвращаемое значение типа Null.<br />
	Null Null() {<br />
		return null;<br />
	}<br />
	//фрагмент 2	<br />
}
В каком фрагменте ошибка компиляции?<br />
**Ответ.**  фрагмент 2<br />
**Источник.**<br />
Удалите этот фрагмент полностью. <br />
Прокомментируйте оставшийся фрагмент и продемонстрируйте функционал класса. <br />
**Ответ.**  public static void main(String[] args) {<br />
	 Null nul = new Null();<br />
	 nul.Null();<br />
	}<br />
**Источник.**

Если метод имеет то же имя, как и класс, то каким образом транслятор определяет где метод, а где конструктор (см. пример выше)?<br />
**Ответ.**  по возвращаемому значению.<br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.

Дан класс.<br />
class Name {<br />
	String name;<br />
	Name() {<br />
		this(makeRandomName());<br />
	}<br />
	Name(String name) {<br />
		super();
		this.name = name;<br />
	}<br />
	String makeRandomName() {<br />
		int k = (int) (Math.random() * 3);<br />
		String name = new String[] {"Alpha", "Beta", "Gamma"}[k];<br />
		return name;<br />
	}<br />
	public String toString() {<br />
		return name;<br />
	}<br />
	public static void main(String[] args) {<br />
		System.out.println(new Name());<br />
	}<br />
}<br />
Объясните причину ошибки компиляции. <br />
Предложите минимум 2 способа исправления ошибки, использовать метод makeRandomName() обязательно.<br />
**Ответ.**  Явный оператор вызова конструктора в теле конструктора не может ссылаться на какие-либо переменные экземпляра, методы экземпляра или внутренние классы, объявленные в этом классе или любом суперклассе, или использовать this или super в любом выражении<br />
1. Cделать метод makeRandomName статическим.<br />
2. Убрать this(makeRandomName()); и реализовать метод при создании объекта System.out.println(new Name().makeRandomName());<br />
**Источник.** 

Дан класс.<br />
class Int {<br />
	int i;<br />
	void inc(Int param) {<br />
		//param = new Int();<br />
		param.i++;<br />
	}<br />
	public static void main(String[] args) {<br />
		Int obj = new Int();<br />
		obj.inc(obj);<br />
		System.out.println(obj.i);<br />
	}<br />
}<br />
Изменится ли результат, если убрать комментарий? <br />
Объясните, почему?<br />
**Ответ.**  ссылка obj и param ссылаются на разные объекты. Без комментария передаваемый параметр obj и параметр param ссылаются на один и тот же объект.<br />
С комментарием создается новый объект, на который устанавливается ссылка param.<br />
**Источник.**<br />

В чем смысл конструкции this? <br />
Перечислите случаи, когда используется конструкция this.<br />
В каких случаях можно обойтись без неё, т.е. заменить другими синтаксическими возможностями. Если можно, то каким образом?<br />
Можно ли присвоить null ссылочной переменной this?<br />
**Ответ.**  конструкция this относится к текущему объекту. Конструкция this используется для вызова конструкторов объекта(this()), для вызова полей и  методов класса при затенении (this.someMember),<br />
для возврата ссылки на текущий объект в методе (return this). Присвоить null ссылочной переменной this нельзя.<br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.

Перечислите случаи, когда используется статический блок?<br />
В каких случаях можно обойтись без него. Если можно, то каким образом?<br />
**Ответ.**  Статическийй блок используется для инициализации статических переменных.Он вызывается только один раз в жизненном цикле приложения при создании<br />
объекта или при обращении к статическому методу (полю) данного класса. <br />
Можно обойтись без статического блока проинициализировав статические поля при их объявлении.<br /> 
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.

Перечислите случаи, когда используется логический блок?<br />
В каких случаях можно обойтись без него. Если можно, то каким образом?<br />
**Ответ.** Логический блок используется для инициализации переменных(не статических).Логические блоки чаще всего используются в качестве инициализаторов<br />
полей, но могут содержать вызовы методов и обращения к полям текущего<br />
класса<br />
Можно обойтись без логического блока проинициализировав поля с помощью конструкторов.<br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.<br />

Что входит в сигнатуру метода?<br />
**Ответ.** <br />
модификатор доступа(обязательно или package private)<br />
тип возвращаемого значения(обязательно)<br />
имя метода(обязательно)<br />
список параметров(обязательно(может быть пустым,но скобки обязательны))() <br />
тело метода {//some code}<br />
Метод также может иметь такие свойства как native, static, abstract, final, synchronized(не обязательно).<br />
Сигнатура в общем виде:<br />
[public/private/protected] [static] [abstract] [final] [synchronized] [native] [<T>] ReturnType<br />
nameMethod(parameters) [throws exceptions]<br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.

Что значит ключевое слово native?<br />
**Ответ.**  Модификатор native сигнализирует о том, что метод реализован в платформо-зависимом коде.<br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.

Дан код. <br />
public class BusinessTrip {<br />
  …<br />
  public String bynToStr(int value) {<br />
    return (value / 100) + "." + (value / 10 % 10) + (value % 10);<br />
  }<br />
}<br />
Есть ли в нем семантическая ошибка?<br />
Если да, то обоснуйте. <br />
**Ответ.**  метод bynToStr является утилитным методом и не подходит по смыслу и логике к классу BusinessTrip(не утилитный класс).<br />
Возможным решением является перенести этот метод в утилитный класс.<br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.

Дан код. <br />
public class Utility {<br />
  private Utility() {<br />
  }<br />
  public String bynToStr(int value) {<br />
    return (value / 100) + "." + (value / 10 % 10) + (value % 10);<br />
  }<br />
}<br />
Есть ли в нем семантическая ошибка?<br />
Если да, то предложите альтернативные варианты. <br />
**Ответ.**  так как этот класс утилитный, хорошим решением будет установить модификатор static для bynToStr.<br />
**Источник.**

К каким данным можно обратиться в статическом методе?<br />
**Ответ.**  к статическим полям и методам, к параметрам метода, к локальным переменным метода.<br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.

Почему нельзя объявить статическое поле внутри метода?<br />
**Ответ.**  Статическое поле относиться к классу, а не к методу.Если бы такое было возможно, слово static теряло бы смысл.<br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.

Перечислите, какой код в классе можно выполнить до создания объекта.<br />
**Ответ.** Статический блок,статические методы, действия с локальными переменными в методе main(), действия со статическими переменными.<br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.
 
В чем различие между объектом и экземпляром класса?<br />
**Ответ.**  экземпляр класса и объект означают одно и то же и часто могут использоваться взаимозаменяемо <br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.


Назовите три этапа создания экземпляра класса.<br />
**Ответ.**  <br />
1.Обьявление: Object object;<br />
2.Создание: new Object();<br />
3.Инициализация: object = new Object();<br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.

Охарактеризуйте отношение композиции между классами? Как оно реализуется?<br />
**Ответ.** Композиция — отношение, когда объект является (отношение HAS A)частью другого объекта.<br />
При использовании композиции объект не только является частью какого-то объекта, но и не может принадлежать другому объекту того же типа<br />
**Источник.**
 
Допустим, необходимо, чтобы метод возвращал два значения одного примитивного типа.<br />
Предложите способы и подтвердите примерами.<br />
**Ответ.**  Возвратить массив примитивного типа.<br />
 public static int[] a(int b,int c) {<br />
	int[] arr = new int[2];<br />
	arr[0] = b;<br />
	arr[1] = c;<br />
	return arr;<br />
    }<br />
**Источник.**

Допустим, необходимо, чтобы метод возвращал два значения разных примитивных типов.<br />
Предложите способы и подтвердите примерами.<br />
**Ответ.** возвратить объект.<br />
public SomeObject someMethod(int a, String b){<br />
	return new SomeObject(a,b);<br />
}
**Источник.**

Что такое иммутабельный объект? <br />
Опишите 2 способа создания иммутабельных объектов. <br />
Подсказка. Способ 1 - класс материала в classes2. <br />
Какой альтернативный? <br />
Подсказка - ключевое слово final для полей не использовать.<br />
Создайте иммутабельный класс для вещества по альтернативному способу. <br />
**Ответ.** <br />
**Источник.**

Даны 2 класса.<br />
final class Material {<br />
	private final String name;<br />
	private final double density;<br />
	...<br />
}<br />
class Runner {<br />
	private static void printMaterial(final Material material) {<br />
        	System.out.println(material);<br />
	}<br />
	public static void main(String[] args) {<br />
        	Material steel = new Material("steel",7850);<br />
        	printMaterial(steel);<br />
	}<br />
}
В методе printMaterial() по ссылке material создается новый объект или имеется доступ к объекту new Material("steel",7850)?<br /> 
Какой пример можно использовать для обоснования ответа?<br />
**Ответ.** 
**Источник.**

Класс для комплексного числа содержит два поля:<br />
class Complex {<br />
	private double re;<br />
	private double im;<br />
	…<br />
}<br />
Реализуйте в данном классе методы: plus() для операции + и add() для +=.<br />
Приведите пример использования каждого метода.<br /><br />
Реализуйте эти же методы при условии, что класс Complex является иммутабельным. 
**Ответ.** <br />
**Источник.**<br />

Для чего предназначен метод toString()?<br />
В каких случаях он вызывается?<br />
Как реализован метод toString() в классе Object?<br />
**Ответ.** public String toString() — возвращает представление объекта в виде строки.toString предназначен для представления информации об обьекте в строковом режиме.<br />
В классе Object тело toString выглядит так: <br />
getClass().getName() + '@' + Integer.toHexString(hashCode());<br />

Для чего предназначен метод equals()?<br />
В каких случаях он вызывается?<br />
**Ответ**public boolean equals(Object ob) — предназначен для использования и переопределения в подклассах с выполнением общих соглашений о сравнении содержимого двух объектов одного и того же типа.<br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.

Как реализован метод equals() в классе Object?<br />
**Ответ.** public boolean equals(Object obj) {<br />
        return (this == obj);<br />
    }<br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.

В чем различие между методом equals() и операции ==?<br />
В каких случаях применение метода equals() и операции == эквивалентно?<br />
**Ответ.**  Метод equals() обозначает отношение эквивалентности объектов. Эквивалентным называется отношение, которое является симметричным, транзитивным и рефлексивным.<br />
Equals можно переопределить.Операция == сравнивает ссылки на объекты, метод equals в классе Object также сравнивает ссылки на объекты.<br />
Если объект ни на что не ссылается(null), то вызов метода equals этого объекта приведет к NullPointerException. при сравнении объектов оба они могут быть null и операция obj1 == obj2 в данном случае будет true.<br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.

Eclipse в стандартной конфигурации генерирует начало метода equals() следующим образом:<br />
public boolean equals(Object obj) {<br />
if (this == obj)<br />
return true;<br />
if (obj == null)<br />
return false;<br />
С чем связаны данные проверки, которые кажутся лишними?<br />
**Ответ.**  При переопределении метода equals() должны выполняться соглашения,<br />
предусмотренные спецификацией языка Java, а именно:<br />
• рефлексивность — объект равен самому себе;<br />
• симметричность — если x.equals(y) возвращает значение true, то и y.equals(x)<br />
всегда возвращает значение true;<br />
• транзитивность — если метод equals() возвращает значение true при сравнении объектов x и y, а также y и z, то и при сравнении x и z будет возвращено значение true;<br />
• непротиворечивость — при многократном вызове метода для двух не подвергшихся изменению за это время объектов возвращаемое значение всегда<br />
должно быть одинаковым;<br />
• **ненулевая ссылка при сравнении с литералом null всегда возвращает значение false.**<br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.

Что такое garbage collection?<br />
**Ответ.**  Сборка мусора — это процесс восстановления заполненной памяти среды выполнения путем уничтожения неиспользуемых объектов.<br />
**Источник.**

Перечислите случаи, когда JVM отдает управление на garbage collector.<br />
**Ответ.** <br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.

Как сделать так, чтобы JVM сразу перешла в режим сборки мусора?<br />
**Ответ.** Форсировать «сборку<br />
мусора» невозможно, можно лишь «рекомендовать» выполнить ее вызовом метода System.gc() или Runtime.getRuntime().gc(), но виртуальная машина выполнит очистку памяти тогда, когда сама посчитает это удобным.<br />
**Источник.**

Гарантирует ли garbage collector, что приложение в любом случае не будет иметь проблемы с недостатком памяти? <br />
Обоснуйте ответ.<br />
**Ответ.** Нет, это не гарантирует этого. Программист вполне может ошибочно создавать объекты, которые никогда не выходят за пределы области видимости, таким образом потребляя все больше и больше памяти, пока вся куча не будет исчерпана.<br />
Ответственность за то, чтобы приложение больше не ссылалось на объекты, которые больше не используются, лежит на программисте.<br />
Если вы продолжите создавать больше объектов в куче, не освобождая их, вы в конечном итоге получите OutOfMemoryError.<br />
**Источник.**https://coderoad.ru/2097461/%D0%93%D0%B0%D1%80%D0%B0%D0%BD%D1%82%D0%B8%D1%80%D1%83%D0%B5%D1%82-%D0%BB%D0%B8-%D1%81%D0%B1%D0%BE%D1%80%D0%BA%D0%B0-%D0%BC%D1%83%D1%81%D0%BE%D1%80%D0%B0-%D1%87%D1%82%D0%BE-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0-%D0%BD%D0%B5-%D0%B1%D1%83%D0%B4%D0%B5%D1%82-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%82%D1%8C-%D0%B1%D0%B5%D0%B7-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8

Для чего предназначен метод finalize()?<br />
Какой недостаток у метода?<br />
**Ответ.** protected void finalize() — (deprecated) автоматически вызывается сборщиком мусора (garbage collection) перед уничтожением объекта;<br />
Запуск стандартного механизма finalization определяется алгоритмом<br />
«сборки мусора», и до его непосредственного исполнения может пройти сколько угодно много времени.<br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.

Для чего предназначены оболочечные классы?<br />
Как они называются на инглише?<br />
**Ответ.** Wrapper-classes это объектное представление примитивных типов, соответсвенно у которых имеются полезные методы.<br />
Wrapper классы используются в работе с коллекциями. Wrapper могут принимать значения null.<br />
**Источник.**

В чем преимущество примитивных типов перед соответствующими оболочечными классами? <br />
**Ответ.**  Производительность, простота.<br />
**Источник.**

Что такое autoboxing и unboxing?<br />
**Ответ.** autoboxing - Это автоматическая инкапсуляция примитивного типа в эквивалентную ему класс-обёртку всякий раз, когда требуется объект данного типа.<br />
Autoboxing происходит:<br />
При присвоении значения примитивного типа переменной соответствующего класса-обёртки.<br />
При передаче примитивного типа в параметр метода, ожидающего соответствующий ему класс-обёртку<br />
unboxing - Это преобразование класса-обёртки в соответствующий ему примитивный тип. Если при распаковке класс-обёртка был равен null, произойдет исключение java.lang.NullPointerException.<br />
**Источник.**https://habr.com/ru/post/329498/

Дан код:
Integer a = 3, b =7;<br />
Long c = a + b;<br />
Перечислите все операции, где задействованы autoboxing и unboxing.<br />
**Ответ.** <br />
Integer a = 3, b =7;//autoboxing, autoboxing<br />
Long c = a + b;// unboxing,unbooxing, operation, autoboxing.<br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.<br />

Дан корректный раннер-класс. <br />
Будет ли ошибка компиляции, если удалить модификатор static из сигнатуры метода main()? <br />
Обоснуйте ответ.<br />
Что произойдет, если отправить на выполнение измененный класс?<br />
**Ответ.** <br />
**Источник.**Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск : Четыре четверти, 2020. — 560 с.<br />

Дан класс.<br />
class Runner {<br />
	public static void main(String[] args) {<br />
        	System.out.println("Hello, world!");<br />
	}<br />
}<br />
Запрещается изменять синий код, т.е. метод main().<br />
Добавить код в класс Runner, так чтобы в результате запуска этого класса из под JVM в консоли был следующий результат:<br />
I am java.<br />
Hello, world!<br />
**Ответ.** <br />
class Runner {<br />
	static {<br />
		System.out.println("I am java");<br />
   	}<br />
	public static void main(String[] args) {<br />
        	System.out.println("Hello, world!");<br />
	}<br />
}<br />
**Источник.**

Бонусное задание 1 (необязательное)
В задаче classes3 имеются два константных поля в классе покупки.
Им сразу присваиваются значения по умолчанию.
Например.
public class Purchase {
  public final static String PRODUCT_NAME = "milk";
  public final static int PRICE = 120;
  ...
}
Измените реализацию так, чтобы константы инициализировались значениями из текстового файла, находящемся в том же пакете, что и класс покупки. Имя файла - константа в классе покупки.<br />
Если будет сбой с файлом или в нем будут недопустимые значения, то присвойте константам PRODUCT_NAME и PRICE значения по умолчанию.<br />
Для этого же примера начало класса должно быть таким:<br />
public class Purchase {<br />
  private static final String PRODUCT_NAME;<br />
  private static final int PRICE;<br />
  public static final String FILE_NAME = "src/by/gsu/epamlab/constants.txt";<br />
  private static final String DEFAULT_PRODUCT_NAME = "milk";<br />
  private static final int DEFAULT_PRICE = 120;<br />
**Ответ.** <br />
**Источник.**

