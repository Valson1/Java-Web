Как по терминологии Java называются базовый класс и наследуемый класс?<br />
**Ответ.** Базовый класс - суперкласс, родительский класс. Наследуемый класс - подкласс,производный класс, расширенный класс, дочерний класс.<br />
**Источник.**https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html<br />

Какой класс является родительским для всех классов?<br />
**Ответ.**.В отсутствие какого-либо другого явного суперкласса каждый класс неявно является подклассом Object.<br />
**Источник.**https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html

Какой класс является родительским для всех перечислений?<br />
**Ответ.**Все перечисления неявно расширяются java.lang.Enum.<br />
**Источник.**https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html

Какой интерфейс является родительским для всех интерфейсов?<br />
 **Ответ.**Такого интерфейса не существует.<br />
**Источник.**

Сформулируйте критерий отношения наследования между двумя сущности физического мира. <br />
Другими словами, какому условию должны удовлетворять две сущности физического мира, чтобы соответствующие им классы были связаны отношением наследования?<br />
**Ответ.**Отношение IS-A и две сущности должны быть одной предметной области.Наследник должен расширять родительский класс.<br />
**Источник.**


Есть ли отношение наследования между сущностями:<br />
а) квадрат и прямоугольник; <br />
б) сосна и доска; <br />
в) книга и страница?<br />
Поясните ответ. <br />
**Ответ.**<br />
а) Да. Изначально есть прямоугольник, а уже его можно представить прямоугольником с одинаковыми сторонами (квадратом). Значит прямоугольник это суперкласс, а квадрат это подкласс.  <br />
б) Нет. Доска это объект созданый из сосны, он не несет того же функционала, что и сосна. Правильное насследование выглядело бы как : Дерево (суперкласс) и Сосна (подкласс).  <br />
в) К отношение книги и страницы логиченее описать как Композицию, книга состоит из страниц, и без страниц ее существование не имеет смысла. Соответсвенно наследование в данном случае так же не логично.  <br />
**Источник.**

В jdk класс RuntimeException является подклассом Exception. <br />
Есть ли нарушение критерия наследования?<br />
Поясните ответ. <br />
**Ответ.** RuntimeException наследуется от Exception, потому-что непроверяемое исключение это все еще исключение, а не ошибка: его можно обработать и оно всегда зависит от кода, а не от сторонних, системных, факторов.<br />
**Источник.https://ru.stackoverflow.com/questions/903495/%D0%98%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8-%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5-%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5**
 
В чем смысл конструкции ​ super​?<br />
Перечислите случаи, когда используется конструкция ​ super​.<br />
**Ответ.** Ключевое слово super используется для:<br />
1.Для обращения к члену суперкласса, скрытому членом подкласса.<br />
2.Для вызова метода суперкласса в переопределенном методе подкласса.<br />
3.Для вызова конструктора суперкласса в конструкторе подкласса. Если конструктор не вызывает явно конструктор суперкласса, компилятор Java автоматически вставляет вызов в конструктор суперкласса без аргументов. Вызывается конструктор класса Object, если суперкласс явно не указан.<br />
Ключевое слово super можно использовать для обращения к члену суперкласса, скрытому членом подкласса.<br />
**Источник.**https://docs.oracle.com/javase/tutorial/java/IandI/super.html

В каких случаях можно обойтись без неё, т.е. заменить другими синтаксическими возможностями. <br />
Если можно, то каким образом?<br />
**Ответ.**Дублирование кода - замена этой конструкции.<br />
**Источник.**

Можно ли одновременно использовать this() и super() в конструкторе?<br /> 
Поясните ответ.<br />
**Ответ.** Нет. Необходимое условие для этих конструкций - быть первым оператором в теле конструктора.<br />
**Источник.**

Дан код. <br />
class SomeClass() {<br />
	...<br />
	public SomeClass() {<br />
		doSmth();<br />
	}<br />
	protected void doSmth() {<br />
		...<br />
	}<br />
}<br />
Это потенциальный антипаттерн. Почему?<br />
**Ответ.**Вызов метода экземпляра в конструкторе опасен, потому что объект еще не полностью инициализирован.<br />
**Источник.**

Если класс реализует некоторый интерфейс, то необходимо ли в нем определить все методы, объявленные в интерфейсе?<br />
**Ответ.**Если класс реализует некоторый интерфейс, он должен реализовать все абстрактные методы.<br />
**Источник.**

Для каких целей необходим интерфейс, в котором не объявлено ни одного метода?<br />
**Ответ.**Интерфейсы без каких-либо методов действуют как маркеры. Они лишь говорят компилятору, что объекты классов, которые имплементят такой интерфейс без методов, должен иметь отличительные черты, восприниматься по-другому. Например, java.io.Serializable, java.lang.Cloneable, java.util.EventListener. Маркерные интерфейсы также известных как "теги", поскольку они добавляют общий тег ко всем унаследованым классам, объединяя их в одну категорию.<br />
**Источник.**

Можно ли переопределить метод в том же самом классе? Можно ли его перегрузить в этом классе?<br />
**Ответ.** Нельзя переопределить метод в одном и том же классе, можно его перегрузить.<br />
**Источник.**

Можно ли переопределить метод в подклассе? Можно ли его перегрузить в подклассе?<br />
**Ответ.** Можно переопределить и перегрузить методы в подклассе.<br />
**Источник.**

Можно ли переопределить статический метод? Поясните ответ.<br />
**Ответ.** Переопределение статических методов невозможно, так как обращение<br />
к статическому методу осуществляется посредством имени класса, которому они принадлежат.<br />
**Источник.**

Как запретить переопределение метода в подклассе? Назовите 2 способа. <br />
**Ответ.** <br />
1. Установить модификатор final в метод.<br /><br />
2. Сделать метод static или private.<br />
**Источник.**

С помощью какого механизма реализуется полиморфизм в Java?<br />
**Ответ.** Механизм «позднего связывания» или «динамического полиморфизма»<br />
в процессе выполнения программы определяет принадлежность объекта конкретному классу и производит вызов метода, относящегося к классу, объект<br />
которого был использован.<br />
**Источник.**

Верно ли утверждение, что если есть ссылка на объект подкласса, то тем самым есть ссылка на объект суперкласса? Если да, то как ее получить?
**Ответ.** .<br />
**Источник.**

SmallEntity и BigEntity - это подклассы Entity.<br />
Можно ли отрефакторить данный код? Если да, то выполните. <br />
class EntityFactory { <br />
public static Entity getEntity(int num) {<br />
		switch(num) {<br />
			case 2: return new Entity();<br />
			case 3: return new SmallEntity();<br />
			case 4: return new BigEntity();<br />
			default: throw new IllegalArgumentException();<br />
		}<br />
}<br />
}<br />
**Ответ.** public class Siuuu  {<br />
    public enum Kind{<br />
	ENTITY{<br />
	    Entity getEntity() {<br />
		return new Entity();<br />
	    }<br />
	}<br />
	,SMALL_ENTITY{<br />
	    Entity getEntity() {<br />
		return new SmallEntity();<br />
	    }<br />
	}<br />
	    <br />
	,BIG_ENTITY{<br />
	    Entity getEntity() {<br />
		return new BigEntity();<br />
	}<br />
	    <br />
	};<br />
	abstract Entity getEntity();<br />
	}<br />
  ...<br />
**Источник.**
Можно ли отрефакторить данный код? Если да, то выполните. <br />
class Entity { <br />
	...<br />
	private String action;<br />
	public void doSmth() {<br />
		switch(action) {<br />
			case "sing-solo": singSolo(); break;<br />
			case "sing-duet": singDuet(); break;<br />
			case "dance": dance();<br />
		}<br />
	}<br />
	private void singSolo() {<br />
		...<br />
	}<br />
	private void singDuet() {<br />
		...<br />
	}<br />
	private void dance() {<br />
		...<br />
	}<br />
}<br />
**Источник.**<br />

Пусть А - абстрактный класс, а - ссылка на А, класс В расширяет класс А. Можно ли создать объект класса В по ссылке а?<br />
Пусть I - интерфейс, i - ссылка на I, b - ссылка на B, класс В реализует интерфейс I. Можно ли создать объект класса В по ссылке i? Можно ли выполнить операции:<br />
1. b = i; ?<br />
2. i = b; ?<br />
**Ответ.**  Пусть А - абстрактный класс, а - ссылка на А, класс В расширяет класс А. Можно ли создать объект класса В по ссылке а:<br />
Можно: A a; a = new B();<br /><br />
Пусть I - интерфейс, i - ссылка на I, b - ссылка на B, класс В реализует интерфейс I. Можно ли создать объект класса В по ссылке i:<br />
Можно: i = new B();<br />
b = i; ? - нельзя;<br />
i = b; ? - можно;<br />
**Источник.**

В чем заключается отличие сравнения принадлежности к классу через операцию instanceof и метод getClass()?<br />
**Ответ.** getClass() устанавливает равенство объектов только из одного и того же класса.instanceof проверяет принадлежность обьекта к иерархии класса.<br />
**Источник.**

Можно ли создать:<br />
1. ссылку на объект абстрактного класса?<br />
2. объект абстрактного класса?<br />
3. ссылку на интерфейс?<br />
4. объект типа интерфейс?<br />
**Ответ.**<br />
1.Можно.<br />
2.Нельзя.<br />
3.Можно.<br />
4.Нельзя.<br />
**Источник.**

Может ли класс:<br />
1. реализовывать два интерфейса?<br />
2. расширять два класса?<br />
3. расширять два интерфейса?<br />
4. расширять один класс и реализовывать один интерфейс?<br />
5. расширять сам себя?<br />
**Ответ.** 
1.Можно.<br />
2.Нельзя.<br />
3.Нельзя.<br />
4.Можно.<br />
5.Нельзя.<br />
**Источник.**

Для каких целей используется расширение интерфейса?<br />
**Ответ.** Расширение интерфейса есть в первую очередь расширение его функционала. Интерфейс может расширять другой интерфейс так же, как класс другой класс. Ключевое слово extends используется для расширения интерфейса, и дочерний интерфейс наследует методы родительского интерфейса.<br />
**Источник.**

Можно ли в интерфейсе<br />
1. объявить метод с пакетным уровнем доступа?<br />
2. объявить конструктор?<br />
3. определить конструктор?<br />
**Ответ.** <br />
1. Package private устанавливается без модификаторы доступа. Все абстрактные методы в интерфейсе устанавливаются как public abstract по умолчанию.<br />
2. Нельзя<br />
**Источник.**

Можно ли интерфейс объявить финальным? Поясните ответ. <br />
**Ответ.** .<br />
**Источник.**

Можно ли в интерфейсе объявить статический метод? Поясните ответ. 
**Ответ.** Разрешается реализовать такой метод в интерфейсе.Статические методы в интерфейсе являются частью интерфейса, мы не можем использовать его для объектов класса реализации.<br />
**Источник.**


Можно ли вызвать статический метод через объектную ссылку? Поясните ответ. <br />
**Ответ.** Вызов статического метода всегда следует осуществлять с помощью указания на имя класса, а не объекта. Статический метод можно вызывать также<br />
с использованием имени объекта, но такой вызов снижает качество кода, приводит к появлению соответствующего предупреждения и не будет логически<br />
корректным, хотя и не закончится ошибкой компиляции.<br />
**Источник.**

Можно ли создать экземпляр класса, у которого есть абстрактный метод? Если да, то зачем?<br />
**Ответ.** Нельзя создать обьект абстрактного класса.<br />
**Источник.**

Должен ли иметь абстрактный класс хотя бы один абстрактный метод? Если нет, то зачем объявлять такой класс абстрактным?<br />
**Ответ.** Абстрактный класс может и не содержать<br />
вовсе абстрактных методов. Предназначение такого класса — быть вершиной<br />
иерархии его различных реализаций.<br />
**Источник.**

Что означает ключевое слово final в следующих конструкциях?<br />
1.<br />
public final class SomeClass() { }<br />
2.<br />
public class SomeClass() {<br />
public final void doSmth();<br />
}<br />
**Ответ.** <br />
1.Класс нельзя расширить подклассами.<br />
2.Метод нельзя переопределить(конечная реализация метода).<br />
**Источник.**

Можно ли объявить метод одновременно финальным и абстрактным? Поясните ответ.<br />
**Ответ.** Нельзя поскольку абстрактный метод должен переопределяться во всех подклассах. Ключевое слово final нарушает это условие.<br />
**Источник.**

К каким методам неприменимы принципы позднего связывания? Почему?<br />
**Ответ.** Статические методы использует механизм раннего связывания.Вызов метода в Java означает, что этот метод привязывается к конкретному коду или в момент компиляции, или во время выполнения, при запуске программы и создании объектов. Так как методы статические (привязаны к классу), то код «знает», какой метод вызывать после компиляции исходного кода на Java в файлы классов.  <br />
**Источник.**

В чем заключается отличие между ранним и поздним связыванием?<br />
**Ответ.** фундаментальное различие между статическим и динамическим связыванием в Java состоит в том, что первое происходит рано, во время компиляции на основе типа ссылочной переменной, а второе – позднее, во время выполнения, с использованием конкретных объектов.
<br />
**Источник.**

