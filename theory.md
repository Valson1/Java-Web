1. Дайте неформальное определение контейнера? <br/>
**Ответ.**  Емкость, для хранения чего-либо.<br/>
**Источник.** 

2.Дайте определение коллекции в java. <br/>
**Ответ.** Коллекция , иногда называемая контейнером, — это просто объект, объединяющий несколько элементов в единое целое . Коллекции используются для хранения, извлечения, обработки и передачи агрегированных данных. Как правило, они представляют собой элементы данных, образующие естественную группу, например покерную комбинацию (набор карт), почтовую папку (набор писем) или телефонный справочник (сопоставление имен и телефонных номеров).<br/>
**Источник.** <https://docs.oracle.com/javase/tutorial/collections/intro/index.html>
 
3. Какой имеется в java контейнер, отличный от коллекций?<br/>
Дайте ему определение. <br/>
**Ответ.** Массив — это объект-контейнер, который содержит фиксированное количество значений одного типа. <br/>
**Источник.** <https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html>

4. Дайте определение Collections framework?<br/>
**Ответ.** Collections Framework - это унифицированная архитектура для представления коллекций и управления ими.<br/>
**Источник.** <https://docs.oracle.com/javase/tutorial/collections/intro/index.html>
 
5. Какие разделы содержит Collections framework?<br/>
Определите их, и для чего они предназначены?<br/>
**Ответ.** 
Интерфейсы: это абстрактные типы данных, представляющие коллекции. Интерфейсы позволяют управлять коллекциями независимо от деталей их представления. В объектно-ориентированных языках интерфейсы обычно образуют иерархию.<br/>
Реализации: это конкретные реализации интерфейсов коллекций. По сути, это повторно используемые структуры данных.<br/>
Алгоритмы:  это методы, которые выполняют полезные вычисления, такие как поиск и сортировка, над объектами, которые реализуют интерфейсы коллекций. Алгоритмы называются полиморфными : то есть один и тот же метод может использоваться во многих различных реализациях соответствующего интерфейса коллекции. По сути, алгоритмы — это повторно используемые функции. <br/>
**Источник.** <https://docs.oracle.com/javase/tutorial/collections/intro/index.html>

6. В чем преимущества использования Collections Framework.<br/>
**Ответ.**Java Collections Framework предоставляет следующие преимущества:<br/>

Сокращает усилия по программированию: Предоставляя полезные структуры данных и алгоритмы, Collections Framework позволяет вам сконцентрироваться на важных частях вашей программы, а не на низкоуровневой «сантехнике», необходимой для ее работы. Упрощая взаимодействие между несвязанными API, Java Collections Framework освобождает вас от написания объектов адаптера или кода преобразования для подключения API.<br/>
Увеличивает скорость и качество программы: эта структура коллекций обеспечивает высокопроизводительные и высококачественные реализации полезных структур данных и алгоритмов. Различные реализации каждого интерфейса взаимозаменяемы, поэтому программы можно легко настраивать, переключая реализации коллекций. Поскольку вы освобождаетесь от рутинной работы по написанию собственных структур данных, у вас появляется больше времени для улучшения качества и производительности программ.<br/>
Обеспечивает взаимодействие между несвязанными API: интерфейсы коллекций — это язык, с помощью которого API передают коллекции туда и обратно. Если мой API-интерфейс сетевого администрирования предоставляет набор имен узлов, а ваш инструментарий графического интерфейса пользователя ожидает набор заголовков столбцов, наши API-интерфейсы будут беспрепятственно взаимодействовать, даже если они были написаны независимо друг от друга.<br/>
Сокращает усилия по изучению и использованию новых API: многие API естественным образом принимают коллекции на входе и предоставляют их на выходе. Раньше у каждого такого API был небольшой суб-API, предназначенный для управления его коллекциями. Между этими специальными API-интерфейсами коллекций было мало согласованности, поэтому вам приходилось изучать каждый из них с нуля, и при их использовании было легко сделать ошибки. С появлением стандартных интерфейсов коллекций проблема ушла.<br/>
Сокращает усилия по разработке новых API: это обратная сторона предыдущего преимущества. Дизайнерам и разработчикам не нужно изобретать велосипед каждый раз, когда они создают API, основанный на коллекциях; вместо этого они могут использовать стандартные интерфейсы коллекций.<br/>
Способствует повторному использованию программного обеспечения: новые структуры данных, соответствующие стандартным интерфейсам коллекций, по своей природе допускают повторное использование. То же самое касается новых алгоритмов, работающих с объектами, реализующими эти интерфейсы. <br/> 
**Источник.** <https://docs.oracle.com/javase/tutorial/collections/intro/index.html>
 
7. Является ли антипаттерном следующее объявление ссылки на коллекцию?<br/>Если да, то как называется антипаттерн и исправьте объявление ссылки.<br/>
Collection collection;<br/>
Если да, то как называется антипаттерн и исправьте объявление ссылки. <br/>
**Ответ.** Да. public interface Collection<E>... . Синтаксис <E>говорит вам, что интерфейс является общим. Когда вы объявляете Collectionэкземпляр, вы можете и должны указать тип объекта, содержащегося в коллекции. Указание типа позволяет компилятору проверить (во время компиляции), что тип объекта, который вы помещаете в коллекцию, является правильным, тем самым уменьшая количество ошибок во время выполнения. <br/>
Collection<SomeObject> collection;
**Источник.** <https://docs.oracle.com/javase/tutorial/collections/interfaces/index.html>
 
8. К каким негативным последствиям может привести использование raw types? <br/>
Приведите пример.<br/>
**Ответ.** Необработанный тип не документирует и не объясняет себя так, как это делает параметризованный тип. <br/>
ClassCastException во время выполнения.<br/>
Необходимость приводить к типу каждый раз.<br/>
**Источник.** <https://docs.oracle.com/javase/tutorial/java/generics/why.html>
 
9. Почему допускаются raw types с коллекциями? <br/>
**Ответ.** Необработанные типы отображаются в устаревшем коде, потому что многие классы API (например, классы Collections ) не были универсальными до JDK 5.0. При использовании необработанных типов вы, по сути, получаете поведение до дженериков.<br/>
**Источник.** <https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html>
 
10. Какое главное назначение раздела Интерфейсы?<br/>
Другими словами, если известен интерфейс коллекции, то что это дает программисту?<br/>
**Ответ.** Интерфейсы позволяют управлять коллекциями независимо от деталей их представления.Если интерфейс коллекции известен, программист знает какую коллекцию он использует,какую математическую сущность она представляет, и устанавливает способ взаимодействия.<br/>
**Источник.** <https://docs.oracle.com/javase/tutorial/collections/intro/index.html>
 
11. Какое главное назначение раздела Имплементации?<br/>
Другими словами, если известна имплементация, то что это дает программисту?<br/>
**Ответ.** Детали реализации конкретного типа коллекции. Дает понять как эффективно будут применяться операции, обьявленные в интерфейсе.<br/>
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/intro/index.html>
 
12. Приведите иерархию интерфейсов коллекций. <br/>
**Ответ.** Iterable -> Collection - корень иерархии. Его наследники: List,Queue -> Deque,Set.В свою очередь Set -> SortedSet -> NavigableSet. Интерфейс Map не входит в эту иерархию, а создает свою Map -> SortetMap -> NavigableMap.Иерархия итераторов Iterator -> ListIterator. <br/>
**Источник.** <https://docs.oracle.com/javase/tutorial/collections/interfaces/index.html>
 
13. Какие существуют способы прохода (traversing) по коллекции до версии java 8 (т.е. от версии 5 до версии 7 включительно)? <br/>
Приведите идиомы для следующей коллекции:<br/>
Collection<Entity> entities = …;<br/>
Какой способ является более подходящим для прохода по коллекции до версии java 8?<br/>
**Ответ.** 1)foreach цикл наиболее подходящая идиома для перебора<br/>

```java
for(Entity entity : entities){
	System.out.println(entity);
}
```

2)Перебор через Iterator <br/>

```java
for(Iterator<Entity> it = entities.iterator();it.hasNext();){
	System.out.println(it.next());
}
```

Использование Iterator.remove() является единственным безопасным способм модификации коллекции во время ее обхода.<br/>
Используйте Iteratorвместо for-eachконструкции, когда вам нужно:<br/>

Удалить текущий элемент. Конструкция for-eachскрывает итератор, поэтому вы не можете вызвать remove. Поэтому эту for-eachконструкцию нельзя использовать для фильтрации.<br/>
Параллельно перебирать несколько коллекций<br/>

**Источник.** <https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html>
 
14. Реализация какого интерфейса позволяет коллекциям использоваться в конструкции for-each?<br/>
Какой метод этого интерфейса обеспечивает данную возможность?<br/>
**Ответ.** Интерфейс Iterable позволяет коллекциям использоваться в конструкции for-each.Метод iterator() обеспечивают данную возможность.<br/>
**Источник.** <https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html>
 
15. Что такое итератор?<br/>
**Ответ.** Итератор - это паттерн для перебора сложной коллекции, без раскрытия деталей ее реализации.Iterator - обьект для перебора коллекции, который позволяет удалять элементы во время перебора,если требуется.<br/>
**Источник.** <>
 
16. Дана коллекция из n элементов. 
Сколько в ней существует возможных позиций курсора итератора?<br/>
**Ответ.** n+1.<br/>
**Источник.**

17. Какие методы объявлены в интерфейсе Iterator<E>?
Охарактеризуйте их. <br/>
**Ответ.** boolean hasNext(); - возвращает true значение, если в итерации больше элементов.
E next() - возвращает следующий элемент в итерации.
void remove - удаление элемента, который держится итератором.<br/>
**Источник.** <https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html>

18. В каких случаях следует явно использовать итератор вместо for-each?<br/>
**Ответ.** 1)Если нужно удалить элемент из коллекции при переборе;<br/>
2)Итерация нескольких коллекций параллельно;<br/>
3)Итерация с конца(ListIterator);<br/>
**Источник.**  

19. Пусть условие удаления элемента из коллекции Collection<Entity> entities задается методом isRemoved() класса Entity. 
Приведите идиому удаления элементов этой коллекции.<br/>
**Ответ.**

```java
for(Iterator<Entity> it = entities.iterator();it.hasNext();){
	if(it.next().isRemoved()){
		it.remove();
	}	
}
```
<br/>
**Источник.** 

20. Какие группы методов (или операций) объявлены в интерфейсе Collection.<br/>
Какие методы входят в каждую группу?<br/>
**Ответ.** основные операции, такие как int size(), boolean isEmpty(), boolean contains(Object element), boolean add(E element), boolean remove(Object element)и Iterator<E> iterator().<br/>
работающие с целыми коллекциями, такие как boolean containsAll(Collection<?> c), boolean addAll(Collection<? extends E> c), boolean removeAll(Collection<?> c), boolean retainAll(Collection<?> c)и void clear().<br/>
методы для операций с массивами (например, Object[] toArray()и <T> T[] toArray(T[] a).<br/>
**Источник.** <https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html>

21. В чем разница методов Object[] toArray(), <T> T[] toArray(T[] a) интерфейса Collection?<br/>
**Ответ.** Простая форма без аргументов создает новый массив Object. Более сложная форма позволяет вызывающей стороне предоставить массив или выбрать тип выходного массива во время выполнения.<br/>
**Источник.** <https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html>
 
22. В описании методов интерфейсов коллекций в JavaDoc есть методы, помеченные фразой “optional operation”.Как это понимать?<br/>
**Ответ.** Чтобы количество основных интерфейсов коллекций оставалось управляемым, платформа Java не предоставляет отдельных интерфейсов для каждого варианта каждого типа коллекции. (Такие варианты могут включать неизменяемый, фиксированный размер и только добавление.) Вместо этого операции модификации в каждом интерфейсе обозначены как необязательные — данная реализация может решить не поддерживать все операции. Если вызывается неподдерживаемая операция, коллекция создает файл UnsupportedOperationException. Реализации несут ответственность за документирование поддерживаемых ими необязательных операций. Все реализации общего назначения платформы Java поддерживают все необязательные операции.<br/> 
**Источник.** <https://docs.oracle.com/javase/tutorial/collections/interfaces/index.html>

23.Какую математическую сущность моделирует интерфейс Set?<br/>
**Ответ.** Множество.<br/>
**Источник.** <https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html>

24. Какое основное свойство всех имплементаций интерфейса Set, т.е. что их объединяет независимо от имплементации?<br/>
**Ответ.** Set коллекция не может содержать повторяющиеся элементы.<br/>
**Источник.** 

25. Может ли множество содержать null элемент?<br/>
**Ответ.** Set не позволяет хранить дублированные элементы, поэтому в Set может находиться только один null элемент.<br/>
**Источник.** <>

26. Есть ли отношение следования (предыдущий, текущий, следующий элемент) в множестве?
Если нет, то есть ли у множества итератор?<br/>
**Ответ.**  Да.<br/>
**Источник.** <>

27. Как получить элемент множества по индексу?<br/>
**Ответ.** List<SomeObject> list = new ArrayList<>(set); list.get(...); <br/>
**Источник.** <>
 
28. Как реализован метод add() во множестве?<br/>
**Ответ.** Метод add добавляет указанный элемент в, Set если он еще не присутствует, и возвращает логическое значение, указывающее, был ли добавлен элемент.<br/>
**Источник.** <https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html>
 
29.Какая группа методов увеличилась в интерфейсе Set по сравнению с интерфейсом Collection?
Какие методы добавились? <br/>
**Ответ.** Интерфейс Set такие же методы, что есть у интерфейса Collection.<br/> 
**Источник.** <https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html>

30.Зависит ли множество, как структура данных, от имплементации?
Обоснуйте ответ.<br/>
**Ответ.** От имплементации зависит только порядок элементов в коллекции и выбор методов для переопределения.Set имеет общую особеннность для всех имплементаций - неповторяющиеся элементы.<br/> 
**Источник.** <>
 
31. Какие методы должны быть переопределены в классе, которым параметризовано множество, чтобы гарантировать правильную работу HashSet имплементации?<br/>
**Ответ.** equals и hashcode. <br/>
**Источник.** <https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html>
 
32. Какие соглашения установлены для переопределения метода hashCode()? <br/>
**Ответ.** 1)Если два объекта равны согласно результату работы equals (Object),
то при вызове для каждого из них метода hashCode должны получиться
одинаковые целочисленные значения.
2) Если метод equals утверждает, что два объекта не равны один
другому, это не означает, что метод hashCode возвратит для них разные
числа. Однако программист должен понимать, что генерация разных чисел
для неравных объектов может повысить производительность хеш-таблиц. 
3)Во время выполнения приложения при многократном вызове для одного
и того же объекта метод hashCode должен всегда возвращать одно и то
же целое число при условии, что никакая информация, используемая при
сравнении этого объекта с другими методом equals, не изменилась. Однако не требуется, чтобы это же значение оставалось тем же при другом
выполнении приложения.
**Источник.** Джошуа Блох 3-е издание Java Эффективное программирование глава 3.2
 
33. Почему недостаточно переопределить один только метод hashCode()?<br/>
**Ответ.** Обьекты имеющие одинаковый hashcose, могут быть не равны по equals. <br/>
**Источник.**
 
34.Являются ли приведенная реализация hashCode() допустимой (в смысле будут ли правильно выполняться все операции над множеством)?

```java
@Override 
public int hashCode() {
return 22;
}
```

**Ответ.**
Это допустимый метод, поскольку он гарантирует, что одинаковые объекты
имеют один и тот же хеш-код. Но он ужасно плохой, потому что каждый объект имеет один и тот же хеш-код. Таким образом, все объекты хранятся в одном
и том же блоке, и хеш-таблица превращается в связанный список. Программа,
которая должна была бы выполняться за линейное время, вместо этого будет
работать квадратичное время  <br/>
**Источник.** Джошуа Блох 3-е издание Java Эффективное программирование глава 3.2
 
35. Являются ли приведенная реализация hashCode() допустимой (в смысле будут ли правильно выполняться все операции над множеством HashSet<Entity>)?

```java
class Entity {
	private int value;
	public int getValue() {
		return value;
	}
	public void setValue(int value) {
		this.value = value;
	}
@Override
public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Entity entity = (Entity) obj;
        return value == entity.value;
}
@Override
public int hashCode() {
        int result = 1;
        result = result * 31 + value;
        return result;
}
}
```

**Ответ.**  Да. <br/>
**Источник.**  

36. Какие методы должны быть переопределены в классе, которым параметризовано множество, чтобы гарантировать правильную работу TreeSet имплементации?<br/>
**Ответ.** compareTo. <br/>
**Источник.** <>
 
37. В чем заключается актуальность внешнего компаратора?<br/>
**Ответ.**  Внешний компаратор реализуется с помощью метода compare ,в котором ,в отличие от compareTo, содержится два аргумента.<br/>
**Источник.** <>
 
38. Можно ли выбрасывать исключения в конструкторах?<br/>
**Ответ.** Если в конструкторе будет выброшено исключение, объект создан не будет - это неплохая практика, т.к. в случае возникновения проблем и инициализацией атрибутов, возможность создания "битого" объекта просто пресекается. <br/>

```
	...
	public Student(String name,int age){
		if (name.trim().isEmpty() || age < 0){
			throw new IllegalArgumentException(...);
		}
	} 
```
**Источник.** <https://docs.oracle.com/javase/tutorial/essential/exceptions/advantages.html> 

39. Может ли произойти потеря исключения? Если да – приведите пример.<br/>
**Ответ.** Да. Например если в блоке finally бросать исключение.<br/>

```
 try {
            try {
                throw new Exception("a");
            } finally {
                if (true) {
                    throw new IOException("b");
                }
                System.err.println("c");
            }
        } catch (IOException ex) {
            System.err.println(ex.getMessage());
        } catch (Exception ex) {
            System.err.println("d");
            System.err.println(ex.getMessage());
        }
    }
```
**Источник.** <http://www.skipy.ru/technics/exceptions.html> 

40. Обладают ли исключения свойством транзакционности?<br/>
**Ответ.** Cвойством транзакционности исключения не обладают – действия, произведенные в блоке try до возникновения исключения, не отменяются поcле его возникновения.<br/>
**Источник.** <http://www.skipy.ru/technics/exceptions.html> 

41. Является ли данный код антипаттерном? <br/>
Обоснуйте ответ. <br/>

```
void methodCatchesSomeException() {
        	...
        	try {
                    	...
        	} catch (SomeException ex) {
                    	...
        	}
        	...
}
```
**Ответ.** Нет.<br/>
**Источник.**  


42. Является ли данный код антипаттерном? <br/>
Обоснуйте ответ. 

```
void methodThrowsSomeCheckedException() {
        	...
        	throw new SomeCheckedException();
        	...
}
```
**Ответ.** Да. Метод должен либо обрабатывать проверяемое исключение либо сообщать о выбросе.<br/>
**Источник.**  
 
43. Является ли данный код верным? Укажите почему.<br/>

```
void methodThrowsSomeCheckedException() throws SomeCheckedException {
        	...
        	throw new SomeCheckedException();
        	...
}
```
**Ответ.** Да.Метод должен либо обрабатывать проверяемое исключение либо сообщать о выбросе, что удовлетворяет примеру.<br/>
**Источник.** 
 
44. Приведите примеры кода с выбросом RuntimeException явным образом и в случае программной ошибки.<br/>
**Ответ.** 

```
if(some < 0){
	throw new IllegalArgumentException("Wrong some");// явным образом
}
SomeObject ob = null;
ob.someMethod;// NPE программная ошибка
```
**Источник.** 
 
45. Можно ли отрефакторить данный код? Если да, то выполните.<br/>

```
void methodThrowsSomeRuntimeException() {
        	...
        	throw new SomeRuntimeException();
        	...
}
```
**Ответ.** Можно, добавив throws в сигнатуру метода

```java
void methodThrowsSomeRuntimeException() throws SomeRuntimeException{
...
throw new SomeRuntimeException();
...
}
```
**Источник.**
 
46. Является ли данный код антипаттерном? <br/>
Обоснуйте ответ. 

```
void methodThrowsSomeRuntimeException() throws SomeRuntimeException {
        	...
        	throw new SomeRuntimeException();
        	...
}
```
**Ответ.** Нет, не является, для исключений-подклассов класса RuntimeException (unchecked) используемых для отображения программных ошибок, при выполнении приложения в объявлении метода секция throws может отсутствовать, так как играет только информационную роль.<br/>
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 276 с.
 
47. В какой версии Java появился оператор try-with-resources? Приведите пример кода с использованием указанного оператора.
**Ответ.** Java SE 7.0

```
 try (FileReader fr = new FileReader(path);
	         BufferedReader br = new BufferedReader(fr)) {
	         return br.readLine();
	    }
```
**Источник.** <https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html>
 
48. Является ли данный код антипаттерном? 
Обоснуйте ответ. 

```
void methodWithAutocloseableInstance() {
        	...
        	try(SomeResource res = new SomeResource(...)) {
                    	...
        	}
        	...
}
```
**Ответ.** Да, т.к. исключение, в случае возникновения, не будет обработано ввиду отсутствия блоков finally, catch.<br/>
**Источник.**

49. Является ли данный код антипаттерном? 
Обоснуйте ответ. 

```
void methodWithAutocloseableInstance() {
        	...
        	try(SomeResource res = new SomeResource(...)) {
                    	...
        	} catch (CorrectCheckedException ex) {
                    	…
        	}
        	...
```
}
**Ответ.** Нет, т.к. try-with-resources позаботится о корректном закрытии ресурсов, а исключение, в случае возникновения, будет обработано.<br/>
**Источник.** 
 
50. Является ли данный код антипаттерном? 
Обоснуйте ответ. 

```
try {
           …
}  catch (SomeException е) {
        	//no code
}
```
**Ответ.** Пустой блок catch лишает смысла механизм исключений, ведь смысл как раз и состоит
в том, чтобы заставить вас обрабатывать исключительную ситуацию.Блок catch обязан содержать, по крайней мере, комментарий, объясняющий, почему данное исключение следует игнорировать.<br/>
**Источник.** Джошуа Блох. Java: эффективное программирование, 3-е издание. Глава 10.7
 
51. Является ли данный код антипаттерном? 
Обоснуйте ответ. 

```
try {
        	…
}  catch (SomeException е) {
    		System.out.println(“Something went wrong!”);
}
```
**Ответ.** Нет, так как исключение не проигнорировано, однако желательно выводить эти сообщения в поток ошибок.<br/>
**Источник.** 
 
52. Является ли данный код антипаттерном, если блок catch находится не в конце раннер-метода main()? 

```
Обоснуйте ответ. 
try {
    		…
}  catch (Exception е) {
    		…
}
…
 
или другой вариант
 
try {
        	…
}  catch (Throwable е) {
        	…
}
```
…
**Ответ.** Нет, блок catch может находиться не в конце раннер-метода main().<br/>
Однако не используйте Exception, RuntimeException, Throwable и Error непосредственно. Рассматривайте эти классы как если бы они были абстрактными. Нельзя надежно протестировать эти исключения, поскольку они являются суперклассами для других исключений, которые может генерировать метод.<br/>
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 368 с.

53. Является ли данный код антипаттерном? 
Обоснуйте ответ.
 
```
try {
    	int i = 0;
  	  while(true) {
        	а[i++].f();
        }
} catch(ArraylndexOutOfBoundsException е) {
    	…
}
```
**Ответ.** Это антипаттерн. Идиома цикла, использующая исключения, не просто снижает производительность и делает непонятным программный код. Нет гарантий, что она вообще будет
работать. Исключения должны применяться только в исключительных ситуациях. <br/>
**Источник.** Java: эффективное программирование, 2-е издание» Джошуа Блох, глава 57.
 
54. Есть ли недостатки у API  написанного только с использованием обрабатываемых исключений?
**Ответ.** Да. Злоупотребление проверяемыми исключениями может сделать API менее
удобным для использования. Если метод выбрасывает одно или несколько проверяемых
исключений, то в программном коде, из которого этот метод был вызван, должна
присутствовать обработка этих исключений в виде одного или нескольких блоков catch
либо должно быть объявлено, что этот код сам выбрасывает исключения и передаёт их
дальше.Такое решение оправданно, если даже при надлежащем применении интерфейса API невозможно предотвратить возникновение условий для исключительной ситуации, однако программист, пользующийся данным API, столкнувшись с этим исключением, мог бы предпринять какие-либо полезные действия. Если не выполняются оба этих условия, лучше пользоваться необрабатываемым исключением. <br/>
**Источник.** Java: эффективное программирование, 2-е издание» Джошуа Блох, глава 57.
 
55. Даны два варианта сеттера.
Какой является более предпочтительным в использовании?
Обоснуйте ответ. 
Вариант 1.

```
void setPositiveValue(int value) {
        	if(value <= 0) {
                    	throw new IllegalArgumentException(...);
        	}
        	this.value = value;
}
```
Вариант 2.

```
void setPositiveValue(int value) throws SomeCheckedException {
        	if(value <= 0) {
                    	throw new SomeCheckedException(...);
        	}
        	this.value = value;
}
```
**Ответ.** Вариант 1.
Повторное использование имеющихся исключений имеет ряд преимуществ.<br/>
Главное среди них то, что они упрощают изучение и применение ваших API, поскольку соответствуют установленным соглашениям, с которыми хорошо знакомы программисты. С этим же связано второе преимущество, заключающееся в том, что программы, использующие ваш API, проще для чтения и понимания, поскольку в них нет незнакомых, сбивающих с толку исключений. Наконец, чем меньше классов исключений, тем меньше требуется места в памяти и времени на их загрузку. <br/>
**Источник.**  Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 367 с.

56. Приведите пример наиболее распространенных из повторно используемых исключений и причины их применения.
**Ответ.** Повторно используемые исключения упрощают освоение и применение API, поскольку
соответствуют установленным соглашениям, с которыми программисты уже знакомы.
С этим же связано второе преимущество, которое заключается в том, что программы,
использующие API, легче читать, поскольку там нет незнакомых, сбивающих с толку
исключений. Наконец, чем меньше классов исключений, тем меньше требуется места в
памяти и времени на их загрузку.<br/>
IllegalAgrumentException - выбрасывается, когда вызываемому методу передаётся аргумент с неправильным значением.<br/>
IllegalStateException - выбрасывается, если в соответствии с состоянием объекта вызов метода является неправомерным.<br/>
NullPointerException - значение параметра равно null,а это запрещено.<br/>
IndexOutOfBoundsException - значение параметра, задающего индекс,выходит за пределы диапазона.<br/>
ConcurrentModificationException - обнаружена параллельная модификация объекта из разных потоков, а это запрещено.<br/>
UnsupportedOperationException - объект не поддерживает вызываемый метод.<br/>
**Источник.** Java: эффективное программирование, 2-е издание» Джошуа Блох, глава 60.

57. Если недостаточно информации для принятия решения и...
1)     исключительная ситуация должна быть исправлена на ближайшем уровне;
2)     исключительная ситуация маловероятна
Экземпляры подклассов каких типов исключений целесообразно сгенерировать в каждом случае?
**Ответ.**  
1) Exception<br/>
2) RuntimeException<br/>
<br/>
**Источник.** Java: эффективное программирование, 2-е издание» Джошуа Блох, глава 58-59.

58. Выделите в блоке try-catch основной и альтернативный сценарии. 
Обоснуйте ответ.

``` 
try {
        	...
        	User user = source.getUser(login, password);
        	if(GUEST_USER.equals(user) {
                    	…
        	} else {
                    	…
        	}
        	...
}  catch (SourceException е) {
    		…
}
class Source {
        	public User getUser(String login, String password) throws SourceException {
                    	...
                    	throw new SourceException(...);
                    	...
                    	return GUEST_USER;	//wrong login or password
                    	...
                    	return new User(...);
        	}
        	...
}
```
**Ответ.** 

```
try {//основной 
        	...
        	User user = source.getUser(login, password);
        	if(GUEST_USER.equals(user) {
                    	…
        	} else {
                    	…
        	}
        	...
}  catch (SourceException е) {// альтернатива
    		…
}
```
	
**Источник.** 
 
59. Перепишите код предыдущего задания с условием, что ввод неправильных логина или пароля является альтернативным сценарием.
**Ответ.** 

```
try {
	        ...
	        User user = source.getUser(login, password);
	        ...
}  catch (SourceException е) {
	...
}  catch(GuestUserException){
   		System.err.println("Insert coorect login or password");
   		...
  	}
}
class Source {
        	public User getUser(String login, String password) throws SourceException {
                    	...
                    	throw new SourceException(...);
                    	...\\if wrong login ow password
                    	throw new GuestUserException;	//wrong login or password
                    	...
                    	return new User(...);
        	}
        	...
}
```

**Источник.** 
 
60. Что такое трансляция исключения, когда ее используют и какие правила ее использования? Приведите пример трансляции исключения.
**Ответ.**  В ситуациях, когда невозможно предотвратить возникновение исключений на нижних уровнях или изолировать от них верхние уровни, как правило,должен применяться механизм трансляции исключений.<br/>
Верхние уровни приложения должны перехватывать исключения нижних уровней и, в свою очередь, выбрасывать исключения, которые можно объяснить в терминах абстракции верхнего уровня.<br/>

```
try {
// Используем абстракцию нижнего уровня
// для выполнения нашей задачи
...
} catch (LowerLevelException е) {
throw new HigherLevelException(...);
}
```
**Источник.** Джошуа Блох. Java: эффективное программирование, 3-е издание. Глава 10.5
 
61. Как можно избежать использования трансляций и зачем нужно это предпринимать?
**Ответ.** Чем больше исключений перехватывается и генерируется, тем больше код, обрабатывающий исключение, будет изолирован от кода, его генерирующего. То есть становится трудным сопоставить точку перехвата с исходной точкой генерации исключения.<br/>
Хотя трансляция исключений лучше, чем бессмысленная передача наверх исключений
с нижних уровней, злоупотреблять ею не следует. Самый хороший способ работы с
исключениями нижнего уровня — полностью исключить их возможность. Для этого
перед вызовом метода нижнего уровня необходимо убедиться в том, что он будет
выполнен успешно. Иногда добиться этого можно путём явной проверки аргументов
метода верхнего уровня перед их передачей на нижний уровень.<br/>
**Источник.** Джошуа Блох. Java: эффективное программирование, 3-е издание. Глава 10.5
 
62. В каких случаях  надо предпочесть сцепление трансляции?
**Ответ.** Сцепление исключений позволяет выбросить исключение, подходящее для верхнего уровня, и при этом сохранить нижележащую причину этого исключения для анализа ошибки. В тех случаях, когда исключение нижнего уровня может быть полезно при анализе ситуации, вызвавшей исключение, лучше использоват сцепление исключений <br/>
**Источник.** Джошуа Блох. Java: эффективное программирование, 3-е издание. Глава 10.5

63. Можно ли для исключительной ситуации определить, класс, который не является подклассом Exception, RuntimeException, Error. 
Если да, то как он будет себя проявлять (как checked-exception или как unchecked-exception)?
**Ответ.** Можно определить подкласс класса Throwable, который не наследует ни от одного из
классов Exception, RuntimeException и Error. В спецификации языка Java такие классы
напрямую не оговариваются, однако неявно подразумевается, что они будут вести
себя так же, как обычные проверяемые исключения (которые являются подклассами
класса Exception, но не RuntimeException). Когда же имеет смысл объявлять такие
классы? Если одним словом, то никогда. Не имея никаких преимуществ перед обычными
проверяемыми исключениеми, они только запутают пользователей вашего API.<br/>
**Источник.**  Java: эффективное программирование, 2-е издание» Джошуа Блох, глава 58.

64. Обязательно ли информацию об исключительное ситуации представлять строковым полем?
Если нет, то какой альтернативный способ создания строкового представления исключения?
**Ответ.** Для фиксации сбоя строковое представление исключения должно содержать значения
всех параметров и полей, «способствовавших появлению этого исключения».Один из приёмов, гарантирующих, что строковое представление исключения будет содержать информацию, достаточную для описания сбоя, состоит в том, чтобы эта информация запрашивалась в конструкторах исключения, а не в строке описания.<br/>

```
public IndexOutOfBoundsException(int lowerBound, int upperBound,int index){
	// Генерируем описание исключения,
	// фиксирующее обстоятельства отказа
	super("Lower bound: " + lowerBound +
		", Upper bound: " + upperBound +
		", Index: " + index);
}
// Сохраняем информацию об ошибке для программного доступа
...
```
**Источник.** 
 
65. Если метод завершается сбоем, что нужно сделать с объектом, на котором был вызван этот метод?
**Ответ.** вызов метода, завершившийся сбоем, должен оставлять обрабатываемый объект в том же
состоянии, в каком тот был перед вызовом.<br/>
**Источник.**  Джошуа Блох. Java: эффективное программирование, 3-е издание. Глава 10.8

66. Приведите способы достижения атомарности по отношению к сбоям.
**Ответ.** 
1.Создание неизменяемых объектов. Если операция заканчивается сбоем, это
может помешать созданию нового объекта, но никогда не оставит уже имеющийся
объект в неопределённом состоянии, поскольку состояние каждого неизменяемого
объекта согласуется в момент его создания и после этого уже не меняется.
Для методов, работающих с изменяемыми объектами, атомарность по отношению к сбою чаще всего достигается путём проверки правильности параметров перед выполнением операции.<br/>
2.Упорядочение вычислений таким образом, чтобы все фрагменты кода, способные повлечь сбой, предшествовали первому фрагменту,который модифицирует объект.<br/>
3.Написание специального кода восстановления (recovery code), который перехватывает сбой, возникающий в ходе выполнения операции, и заставляет объект вернуться в то состояние, в котором он находился в момент, предшествующий началу операции.<br/>
4.Выполнение операции на временной копии объекта и, как только операция будет завершена, замещать содержимое объекта содержимым его временной копии.<br/>
**Источник.**  Джошуа Блох. Java: эффективное программирование, 3-е издание. Глава 10.8

67. Приведите пример, когда отсутствие транзакционности в исключениях, приводит к сохранению ссылки на объект в неверном состоянии.
**Ответ.**

```
public class PartialInitTest{

    static PartialInitTest self;

    private int field1 = 0;
    private int field2 = 0;

    public PartialInitTest(boolean fail) throws Exception{
        self = this;
        field1 = 1;
        if (fail) {
            throw new Exception();
        }
        field2 = 1;
    }

    public boolean isConsistent(){
        return field1 == field2;
    }

    public static void main(String[] args){
        PartialInitTest pit = null;
        try {
            pit = new PartialInitTest(true);
        } catch (Exception ex){
            // do nothing
        }
        System.out.println("pit: "+pit);
        System.out.println("PartialInitTest.self reference: "+PartialInitTest.self);
        System.out.println("PartialInitTest.self.isConsistent(): "+PartialInitTest.self.isConsistent());
    }
}
```
**Источник.** <http://www.skipy.ru/technics/exceptions.html>

68. Необходимо создать коллекцию из результатов тестов, находящихся в валидном файле src/in.csv.
Пример файла
cool;75;90
clever;68;95
looser;30;48
Является ли код, реализующий задание, антипаттерном? 
Обоснуйте ответ. 

```
public class Runner {
        	public static void main(String[] args) {
                    	List<Trial> trials = new ArrayList<Trial>();
                    	try(Scanner sc = new Scanner(new FileReader("src/in.csv"))) {
                               	while(sc.hasNext()) {
                                           	Trial trial = getTrial(sc);
                                           	trials.add(trial);
                               	}
                               	printTrials(trials);
                    	} catch (FileNotFoundException e) {
                               	System.out.println(Constants.ERROR_FILE_FOUND);
                    	}
        	}
        	private static Trial getTrial(Scanner sc) {
                    	String csvLine = sc.nextLine();
                    	String[] values = csvLine.split(Constants.DELIMETER);   	
                    	try {
                               	String name = values[Constants.NAME_INDEX];
                               	int mark1 = Integer.parseInt(values[Constants.MARK1_INDEX]);
                               	int mark2 = Integer.parseInt(values[Constants.MARK2_INDEX]);
                   		return new Trial(name, mark1, mark2);
                    	} catch (CsvLineException e) {
                               	System.out.println(Constants.ERROR_WRONG_DATA);
                    	}
        	}
```
**Ответ.** Исключения следует генерировать на нижних уровнях.<br/>

```
private static Trial getTrial(Scanner sc) throws CsvLineException{
	String csvLine = sc.nextLine();
	String[] values = csvLine.split(Constants.DELIMETER);
	try {
		String name = values[Constants.NAME_INDEX];
		int mark1 = Integer.parseInt(values[Constants.MARK1_INDEX]);
		int mark2 = Integer.parseInt(values[Constants.MARK2_INDEX]);
		return new Trial(name, mark1, mark2);
	} catch (CsvLineException e) {
		throw new CsvLineException();
	}
}
```


**Источник.** 
 
69. Приведите пример кода собственного исключения (реализация в одном классе всего нижеперечисленного). Класс исключения содержит:
-         поле, которым является неправильная строка, считанная из файла (имя csvLine);
-         конструктор по умолчанию, вызывающий конструктор суперкласса;
-         параметризованный конструктор, принимающий экземпляр исключения и неправильную строку, считанную из файла;
-         параметризованный конструктор, принимающий строку с указанием причины исключения и  неправильную строку, считанную из файла;
-         геттер с возвратом неправильной строки;
-         переопределенного метода toString с указанием неправильной строки и метода вывода сообщения об ошибки.


**Ответ.** 
<br/>

```
public class CsvLineException extends Exception {
    private String csvLine;

    public CsvLineException(String csvLine) {
	this.csvLine = csvLine;
    }

    public CsvLineException() {
    }

    public CsvLineException(String csvLine, Throwable cause) {
	super(csvLine,cause);
	this.csvLine = csvLine; 
    }

    public CsvLineException(String csvLine, String causeMessage) {
	super(causeMessage);
	this.csvLine = csvLine;
    }
    
    public String getCsvLine() {
	return csvLine;
    }
    
    @Override
    public String toString() {
        return csvLine + ";" + getMessage();
    }
 }
```
**Источник.** 
  
70. Необходимо создать метод для экспорта csv-файла в коллекцию.
При наличии хотя бы одной ошибки в исходных данных “отменить” создание 
коллекции.
Какие антипаттерны содержит следующий код? 
Предложите варианты по избавлению от них.

```
private static List<Trial> getTrials(Scanner sc) {
List<Trial> trials = new ArrayList<Trial>();
try {
while(sc.hasNext()) {
Trial trial = getTrial(sc);
trials.add(trial);
}
} catch (CsvLineException e) {
System.err.println(e);
}
return trials;
}
```
**Ответ.** При валидных обьектах trial, список trials будет заполняться. Как только обьект trial окажется некорректным и сгенерируется исключение,тот список trials с обьектами trial, возвратиться методом.Для избавления от этого можно в блоке catch вернуть null или пустой список.<br/>
**Источник.** 

72. Создать метод для экспорта данных в коллекцию из последовательного источника экземпляров Trial.
См. код ниже.
Его необходимо дополнить, чтобы происходила обработка следующих исключительных ситуаций:
1. 	Файл не найден.
2. 	Ошибка в csv строке.

```
interface TrialProvidable {
	boolean hasTrial();
	Trial getTrial();
}
 
public class TrialCsvImpl implements TrialProvidable {
	private Scanner sc;
	public CsvImpl(String csvName) {            	
		sc = new Scanner(new FileReader(csvName));
	}
	public boolean hasTrial() {             	
		return sc.hasNextLine();
	}
	public Trial getTrial() {
		// get Trial instance from csv line
		return trial;
	}
}
 
public class Runner {
	private static List<Trial> getTrials(TrialProvidable trialProvider) {
		List<Trial> trials = new ArrayList<Trial>();
		while(trialProvider.hasTrial()) {
			Trial trial = trialProvider.getTrial();
			trials.add(trial);
		}
		return trials;
	}
 
	public static void main(String[] args) {
		TrialProvidable trialProvider = null;
		try {
			if("csv".equals(args[0])) {
				trialProvider = new TrialCsvImpl("src/in.csv");
			} else {
				trialProvider = new TrialDBImpl();
			}
		List<Trial> trials = getTrials(trialProvider);
…
		} finally {
			if (trialProvider != null) {
				trialProvider.close();
			}
		}
	}
}

```
**Ответ.**

```
 interface TrialProvidable {
	boolean hasTrial();
	Trial getTrial();
}
 
public class TrialCsvImpl implements TrialProvidable {
	private Scanner sc;
	public CsvImpl(String csvName)throws FileNotFoundException {            	
		sc = new Scanner(new FileReader(csvName));
	}
	public boolean hasTrial() {             	
		return sc.hasNextLine();
	}
	public Trial getTrial() throws CsvLineException{
		try{
			Trial trial = new Trial(...);
			return trial;
		catch(SomeException e){
			throw new CsvLineException(...);
		}
	}
}
 
public class Runner {
	private static List<Trial> getTrials(TrialProvidable trialProvider) {
		List<Trial> trials = new ArrayList<Trial>();
		try{
			while(trialProvider.hasTrial()) {
				Trial trial = trialProvider.getTrial();
				trials.add(trial);
			}
		}catch(CsvLineException e){
			System.err.println(...);
		}
		return trials;
	}
 
public static void main(String[] args) {
TrialProvidable trialProvider = null;
	try {
		if("csv".equals(args[0])) {
			trialProvider = new TrialCsvImpl("src/in.csv");
		} else {
			trialProvider = new TrialDBImpl();
		}
		List<Trial> trials = getTrials(trialProvider);
	}catch(FileNotFoundException e){
		System.out.println("File is not found");
	}finally {
		if (trialProvider != null) {
			trialProvider.close();
		}
	}
}
}
```
**Источник.**